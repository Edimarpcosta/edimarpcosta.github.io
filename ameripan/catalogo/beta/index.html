<!DOCTYPE html>
<html lang="pt-BR" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Catálogo de Produtos - Ameripan</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        :root {
            /* Variáveis para o modo claro (padrão) */
            --bg-primary: #f8f9fa; /* [1] */
            --bg-secondary: #ffffff; /* [2] */
            --primary-color: #3498db; /* [2] */
            --secondary-color: #2980b9; /* [2] */
            --text-color: #333333; /* [2] */
            --text-secondary: #777777; /* [2] */
            --border-color: #dddddd; /* [2] */
            --hover-color: rgba(0, 0, 0, 0.05); /* [2] */
            --card-shadow: 0 2px 8px rgba(0, 0, 0, 0.05); /* [3] */
            --header-shadow: 0 2px 10px rgba(0, 0, 0, 0.1); /* [3] */
            --modal-overlay: rgba(0, 0, 0, 0.8); /* [4] */
            --accent-color: #e67e22; /* [4] */
            --success-color: #27ae60; /* [4] */
            --error-color: #e74c3c; /* [4] */

            /* === VARIÁVEIS PARA COLUNAS DINÂMICAS === */
            --coluna-produto-min-width-base: 110px; /* Valor padrão para telas grandes */
            --coluna-produto-min-width: var(--coluna-produto-min-width-base); /* Variável usada pelo grid */
            /* === FIM DAS VARIÁVEIS === */
        }

        [data-theme="dark"] {
            /* Variáveis para o modo escuro */
            --bg-primary: #1a1a1a; /* [5] */
            --bg-secondary: #2d2d2d; /* [6] */
            --primary-color: #2196f3; /* [6] */
            --secondary-color: #1976d2; /* [6] */
            --text-color: #f0f0f0; /* [6] */
            --text-secondary: #bbbbbb; /* [6] */
            --border-color: #444444; /* [6] */
            --hover-color: rgba(255, 255, 255, 0.05); /* [6] */
            --card-shadow: 0 2px 8px rgba(0, 0, 0, 0.3); /* [7] */
            --header-shadow: 0 2px 10px rgba(0, 0, 0, 0.3); /* [7] */
            --modal-overlay: rgba(0, 0, 0, 0.9); /* [8] */
            --accent-color: #f39c12; /* [8] */
             /* === VARIÁVEIS PARA COLUNAS DINÂMICAS === */
             --coluna-produto-min-width-base: 110px; /* Valor padrão para telas grandes */
            --coluna-produto-min-width: var(--coluna-produto-min-width-base); /* Variável usada pelo grid */
            /* === FIM DAS VARIÁVEIS === */
        }

        * {
            margin: 0; /* [8] */
            padding: 0; /* [9] */
            box-sizing: border-box; /* [9] */
            transition: background-color 0.3s, color 0.3s; /* [9] */
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; /* [9] */
            background-color: var(--bg-primary); /* [10] */
            color: var(--text-color); /* [10] */
            line-height: 1.6; /* [10] */
        }

        .container {
            max-width: 1400px; /* [10] */
            margin: auto; /* [11] */
            padding: 0 15px; /* [11] */
        }

        header {
            background-color: var(--primary-color); /* [11] */
            color: white; /* [12] */
            padding: 20px 0; /* [12] */
            margin-bottom: 20px; /* [12] */
            box-shadow: var(--header-shadow); /* [12] */
            position: sticky; /* [12, 235] */
            top: 0; /* [12, 235] */
            z-index: 100; /* [12, 235] */
            transition: transform 0.3s ease, box-shadow 0.3s, background-color 0.3s; /* [235, 256, 280] */
        }

        header.hide {
            transform: translateY(-100%); /* [235, 256, 280] */
            box-shadow: none; /* [235, 256] */
        }

        h1 {
            text-align: center; /* [13] */
            font-size: 2.2rem; /* [14] */
            font-weight: 600; /* [14] */
            margin: 0; /* [14] */
        }

        .header-controls {
            display: flex; /* [14] */
            justify-content: space-between; /* [15] */
            align-items: center; /* [15] */
            margin-top: 10px; /* [15] */
            flex-wrap: wrap; /* [244] */
        }

        .theme-toggle {
            display: flex; /* [15] */
            align-items: center; /* [16] */
            cursor: pointer; /* [16] */
            padding: 5px 10px; /* [16] */
            border-radius: 20px; /* [16] */
            background-color: rgba(255, 255, 255, 0.2); /* [16] */
            transition: background-color 0.3s, transform 0.2s, box-shadow 0.3s; /* [16, 254] */
        }

        .theme-toggle:hover {
            background-color: rgba(255, 255, 255, 0.3); /* [17] */
        }

        .theme-toggle i {
            margin-right: 5px; /* [18] */
        }

        .mode-toggle {
            display: flex; /* [19] */
            align-items: center; /* [20] */
            cursor: pointer; /* [20] */
            padding: 5px 15px; /* [20] */
            border-radius: 20px; /* [20] */
            background-color: var(--accent-color); /* [20] */
            color: white; /* [20] */
            font-weight: 500; /* [20] */
            transition: background-color 0.3s, transform 0.2s, box-shadow 0.3s; /* [20, 254] */
        }

        .mode-toggle:hover {
            background-color: #d35400; /* [21] */
        }

        .mode-toggle i {
            margin-right: 8px; /* [22] */
        }

        .cart-indicator, .collection-indicator {
            display: flex; /* [23] */
            align-items: center; /* [24] */
            cursor: pointer; /* [24] */
            padding: 5px 10px; /* [24] */
            border-radius: 20px; /* [24] */
            background-color: rgba(255, 255, 255, 0.2); /* [24] */
            transition: background-color 0.3s; /* [24] */
        }

        .cart-indicator:hover, .collection-indicator:hover {
            background-color: rgba(255, 255, 255, 0.3); /* [25] */
        }

        .cart-count, .collection-count {
            margin-left: 5px; /* [26] */
            background-color: white; /* [27] */
            color: var(--primary-color); /* [27] */
            border-radius: 50%; /* [27] */
            width: 20px; /* [27] */
            height: 20px; /* [27] */
            display: flex; /* [27] */
            align-items: center; /* [27] */
            justify-content: center; /* [27] */
            font-size: 0.8rem; /* [27] */
            font-weight: bold; /* [27] */
        }

        .header-search { /* [236, 257, 285] */
            flex: 1;
            max-width: 500px;
            margin: 0 15px;
            transform: scale(1); /* [285] */
            transition: transform 0.3s; /* [285] */
        }

        .header-search:focus-within { /* [286] */
             transform: scale(1.05);
        }

        .header-search .search-container { /* [237, 258] */
             position: relative;
             width: 100%;
        }

        .header-search .search-icon { /* [238, 259, 290] */
            position: absolute;
            left: 15px;
            top: 50%;
            transform: translateY(-50%);
            color: rgba(255, 255, 255, 0.8);
            font-size: 1.2rem; /* [290] */
        }

        .header-search #header-search { /* [239, 260, 287] */
            width: 100%;
            padding: 10px 15px 10px 45px;
            border: none;
            border-radius: 50px;
            font-size: 1rem;
            background-color: rgba(255, 255, 255, 0.25);
            color: white;
            transition: all 0.3s; /* [240, 261, 288] */
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1); /* [288] */
        }

        .header-search #header-search::placeholder { /* [241, 262] */
            color: rgba(255, 255, 255, 0.7);
        }

        .header-search #header-search:focus { /* [242, 263, 289] */
            background-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15); /* [289] */
            outline: none;
        }


        .vendor-controls {
            display: flex; /* [28] */
            justify-content: space-between; /* [29] */
            align-items: center; /* [29] */
            background-color: var(--accent-color); /* [29] */
            color: white; /* [29] */
            padding: 12px 20px; /* [29] */
            margin-bottom: 20px; /* [29] */
            border-radius: 8px; /* [29] */
            box-shadow: var(--card-shadow); /* [29] */
        }

        .collection-actions {
            display: flex; /* [30] */
            gap: 10px; /* [31] */
        }

        .vendor-btn {
            padding: 8px 15px; /* [31] */
            border-radius: 4px; /* [32] */
            border: none; /* [32] */
            background-color: white; /* [32] */
            color: var(--accent-color); /* [32] */
            cursor: pointer; /* [32] */
            display: flex; /* [32] */
            align-items: center; /* [32] */
            font-weight: 500; /* [32] */
            transition: all 0.2s, transform 0.2s, box-shadow 0.3s; /* [32, 254] */
        }

        .vendor-btn i {
            margin-right: 5px; /* [33] */
        }

        .vendor-btn:hover { /* [34, 255] */
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .vendor-btn.save {
            background-color: #2ecc71; /* [35] */
            color: white; /* [36] */
        }

        .vendor-btn.pdf {
            background-color: #e74c3c; /* [36] */
            color: white; /* [37] */
        }

        .vendor-btn.manage {
            background-color: #3498db; /* [37] */
            color: white; /* [38] */
        }

        .collection-info {
            display: flex; /* [38] */
            align-items: center; /* [39] */
            gap: 20px; /* [39] */
        }

        .collection-name {
            display: flex; /* [39] */
            align-items: center; /* [40] */
            gap: 10px; /* [40] */
        }

        .collection-name input {
            background: rgba(255, 255, 255, 0.2); /* [40] */
            border: none; /* [41] */
            border-radius: 4px; /* [41] */
            padding: 5px 10px; /* [41] */
            color: white; /* [41] */
            width: 200px; /* [41] */
        }

        .collection-name input::placeholder {
            color: rgba(255, 255, 255, 0.7); /* [42] */
        }

        .selection-count {
            background-color: white; /* [43] */
            color: var(--accent-color); /* [44] */
            padding: 2px 10px; /* [44] */
            border-radius: 50px; /* [44] */
            font-weight: bold; /* [44] */
            font-size: 0.9rem; /* [44] */
        }

        .filters {
            display: flex; /* [45] */
            flex-wrap: wrap; /* [46] */
            gap: 15px; /* [46] */
            margin-bottom: 25px; /* [46] */
            padding: 15px; /* [46] */
            background-color: var(--bg-secondary); /* [46] */
            border-radius: 8px; /* [46] */
            box-shadow: var(--card-shadow); /* [46] */
            align-items: center; /* [46] */
        }

        .filters-main {
            display: flex; /* [47] */
            flex-wrap: wrap; /* [48] */
            gap: 15px; /* [48] */
            flex: 1; /* [48] */
            min-width: 200px; /* [48] */
        }

        .search-container {
            position: relative; /* [48] */
            flex: 1; /* [49] */
            min-width: 200px; /* [49] */
        }

        #search {
            width: 100%; /* [49] */
            padding: 10px 15px 10px 40px; /* [50] */
            border: 1px solid var(--border-color); /* [50] */
            border-radius: 50px; /* [50] */
            font-size: 1rem; /* [50] */
            background-color: var(--bg-secondary); /* [50] */
            color: var(--text-color); /* [50] */
        }

        .search-icon {
            position: absolute; /* [51] */
            left: 15px; /* [52] */
            top: 50%; /* [52] */
            transform: translateY(-50%); /* [52] */
            color: var(--text-secondary); /* [52] */
        }

        .select-container {
            position: relative; /* [52] */
            min-width: 150px; /* [53] */
        }

        select {
            padding: 10px 15px; /* [53] */
            border: 1px solid var(--border-color); /* [54] */
            border-radius: 50px; /* [54] */
            background-color: var(--bg-secondary); /* [54] */
            color: var(--text-color); /* [54] */
            font-size: 1rem; /* [54] */
            width: 100%; /* [54] */
            -webkit-appearance: none; /* [54] */
            -moz-appearance: none; /* [54] */
            appearance: none; /* [54] */
            cursor: pointer; /* [55] */
        }

        .select-icon {
            position: absolute; /* [55] */
            right: 15px; /* [56] */
            top: 50%; /* [56] */
            transform: translateY(-50%); /* [56] */
            color: var(--text-secondary); /* [56] */
            pointer-events: none; /* [56] */
        }

        .filters-advanced {
            display: none; /* [57] */
            flex-wrap: wrap; /* [58] */
            gap: 15px; /* [58] */
            width: 100%; /* [58] */
            margin-top: 10px; /* [58] */
            padding-top: 10px; /* [58] */
            border-top: 1px solid var(--border-color); /* [58] */
        }

        .filters-toggle {
            display: flex; /* [59] */
            align-items: center; /* [60] */
            padding: 8px 15px; /* [60] */
            border-radius: 50px; /* [60] */
            background-color: var(--primary-color); /* [60] */
            color: white; /* [60] */
            cursor: pointer; /* [60] */
            font-size: 0.9rem; /* [60] */
        }

        .filters-toggle i {
            margin-left: 5px; /* [61] */
            transition: transform 0.3s; /* [62] */
        }

        .filters-toggle.active i {
            transform: rotate(180deg); /* [62] */
        }

        .category-section {
            margin-bottom: 40px; /* [63] */
            background-color: var(--bg-secondary); /* [64] */
            border-radius: 8px; /* [64] */
            padding: 20px; /* [64] */
            box-shadow: var(--card-shadow); /* [64] */
        }

        .category-title {
            font-size: 1.5em; /* [64] */
            margin-bottom: 20px; /* [65] */
            border-bottom: 2px solid var(--primary-color); /* [65] */
            padding-bottom: 10px; /* [65] */
            color: var(--secondary-color); /* [65] */
            text-transform: capitalize; /* [65] */
            display: flex; /* [65] */
            justify-content: space-between; /* [65] */
            align-items: center; /* [65] */
        }

        .category-selection {
            display: flex; /* [66] */
            align-items: center; /* [67] */
            gap: 10px; /* [67] */
        }

        .select-all-cat {
            padding: 3px 10px; /* [67] */
            border-radius: 50px; /* [68] */
            border: 1px solid var(--primary-color); /* [68] */
            background-color: var(--bg-secondary); /* [68] */
            color: var(--primary-color); /* [68] */
            font-size: 0.8rem; /* [68] */
            cursor: pointer; /* [68] */
            transition: all 0.2s; /* [68] */
        }

        .select-all-cat:hover {
            background-color: var(--primary-color); /* [69] */
            color: white; /* [70] */
        }

        /* === MODIFICAÇÃO PRINCIPAL PARA COLUNAS DINÂMICAS === */
        .products {
            display: grid; /* [70] */
            grid-template-columns: repeat(auto-fill, minmax(var(--coluna-produto-min-width), 1fr)); /* [71] - AGORA USA A VARIÁVEL */
            gap: 20px; /* [71] */
        }
        /* === FIM DA MODIFICAÇÃO PRINCIPAL === */


        .products.list-view { /* [264] */
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .product {
            display: flex; /* [71] */
            flex-direction: column; /* [72] */
            background-color: var(--bg-secondary); /* [72] */
            border-radius: 12px; /* [72, 245, 276] */
            overflow: hidden; /* [72, 245] */
            transition: transform 0.4s, box-shadow 0.4s, border-color 0.3s; /* [72, 245, 276] */
            box-shadow: var(--card-shadow); /* [72] */
            border: 1px solid transparent; /* [72, 276] */
            position: relative; /* [73] */
            height: 100%; /* [245] */
            animation: fadeIn 0.3s ease; /* [269] */
        }

        .product:hover { /* [74, 246, 277] */
            transform: translateY(-12px) scale(1.03);
            box-shadow: 0 16px 30px rgba(0, 0, 0, 0.15);
            border-color: var(--primary-color); /* [246, 277] */
            z-index: 10; /* [278] */
        }

        .product.selected {
            border: 2px solid var(--accent-color); /* [74] */
        }

        .products.list-view .product { /* [265] */
            display: flex;
            flex-direction: row;
            height: auto;
            max-width: 100%;
        }


        .product-img-container {
            height: 180px; /* [75] */
            overflow: hidden; /* [76, 247] */
            display: flex; /* [76] */
            align-items: center; /* [76] */
            justify-content: center; /* [76] */
            background-color: var(--bg-secondary); /* [76] */
            position: relative; /* [76, 247] */
            background: linear-gradient(to bottom right, rgba(0,0,0,0.02), rgba(0,0,0,0.05)); /* [247] */
        }

         .products.list-view .product-img-container { /* [265] */
            width: 120px;
            height: 120px;
            flex-shrink: 0;
        }


        .product img {
            max-width: 90%; /* [77] */
            max-height: 90%; /* [78] */
            object-fit: contain; /* [78, 248] */
            transition: transform 0.5s ease, opacity 0.3s; /* [78, 248, 279] */
        }

        .product img:hover { /* [248] */
             transform: scale(1.1);
        }

        .product:hover .product-img-container img { /* [279] */
            transform: scale(1.15);
        }

        .lazy-img { /* [275] */
             opacity: 0;
             transition: opacity 0.5s;
        }

        .lazy-img.loaded { /* [275] */
             opacity: 1;
        }


        .product-actions {
            display: flex; /* [78, 249] */
            position: absolute; /* [79, 249] */
            top: 10px; /* [79, 249] */
            right: 10px; /* [79, 249] */
            gap: 8px; /* [79, 249] */
            opacity: 0; /* [79, 249] */
            transition: opacity 0.3s, transform 0.3s; /* [79, 249] */
            transform: translateY(-10px); /* [249] */
        }

        .product:hover .product-actions { /* [80, 250] */
            opacity: 1;
            transform: translateY(0);
        }

        .product-action-btn { /* [81, 251] */
            width: 36px;
            height: 36px;
            border-radius: 50%; /* [82, 251] */
            background-color: rgba(255, 255, 255, 0.9); /* [82, 251] */
            color: var(--primary-color); /* [82, 251] */
            display: flex; /* [82, 251] */
            align-items: center; /* [82, 251] */
            justify-content: center; /* [82, 251] */
            cursor: pointer; /* [82, 251] */
            transition: all 0.2s; /* [83, 251] */
            backdrop-filter: blur(4px); /* [252] */
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.1); /* [252] */
        }

        .product-action-btn:hover { /* [84, 253] */
            background-color: var(--primary-color);
            color: white;
        }

        .product-select {
            position: absolute; /* [84] */
            top: 10px; /* [85] */
            left: 10px; /* [85] */
            width: 24px; /* [85] */
            height: 24px; /* [85] */
            border-radius: 50%; /* [85] */
            background-color: var(--bg-secondary); /* [85] */
            border: 2px solid var(--border-color); /* [85] */
            display: flex; /* [85] */
            align-items: center; /* [85] */
            justify-content: center; /* [86] */
            cursor: pointer; /* [86] */
            transition: all 0.2s; /* [86] */
            color: transparent; /* [86] */
        }

        .product.selected .product-select {
            background-color: var(--accent-color); /* [86] */
            border-color: var(--accent-color); /* [87] */
            color: white; /* [87] */
        }

        .product-info {
            padding: 15px; /* [88] */
            display: flex; /* [89] */
            flex-direction: column; /* [89] */
            flex-grow: 1; /* [89] */
        }

         .products.list-view .product-info { /* [266] */
             flex: 1;
             display: flex;
             flex-direction: column;
        }


        .product-sku {
            display: inline-block; /* [89] */
            padding: 3px 8px; /* [90] */
            background-color: rgba(52, 152, 219, 0.1); /* [90] */
            color: var(--primary-color); /* [90] */
            border-radius: 50px; /* [90] */
            font-size: 0.8rem; /* [90] */
            font-weight: 500; /* [90] */
            margin-bottom: 8px; /* [90] */
            align-self: flex-start; /* [90] */
        }

        .product-name {
            font-size: 0.95rem; /* [91] */
            margin-bottom: 5px; /* [92] */
            line-height: 1.3; /* [92] */
            display: -webkit-box; /* [92] */
            -webkit-line-clamp: 2; /* [92] */
            -webkit-box-orient: vertical; /* [92] */
            overflow: hidden; /* [92] */
            flex-grow: 1; /* [92] */
        }

        .product-category {
            font-size: 0.8rem; /* [93] */
            color: var(--text-secondary); /* [94] */
            text-transform: capitalize; /* [94] */
        }

        .product-package {
            font-size: 0.8rem; /* [94] */
            color: var(--primary-color); /* [95] */
            margin-top: 5px; /* [95] */
        }

        .price-input-group { /* [169] */
             position: relative;
             margin-top: 10px;
        }

         .price-input-group .currency-symbol { /* [170] */
            position: absolute;
            left: 10px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-secondary);
        }

        .price-input-group input { /* [171] */
            padding-left: 25px;
        }

        .product-price-input {
            width: 100%; /* [95] */
            margin-top: 10px; /* [96] */
            padding: 5px; /* [96] */
            border: 1px solid var(--border-color); /* [96] */
            border-radius: 4px; /* [96] */
            background-color: var(--bg-secondary); /* [96] */
            color: var(--text-color); /* [96] */
            font-size: 0.9rem; /* [96] */
        }

        .product-controls {
            display: flex; /* [97] */
            justify-content: space-between; /* [98] */
            align-items: center; /* [98] */
            margin-top: 15px; /* [98] */
            border-top: 1px solid var(--border-color); /* [98] */
            padding-top: 10px; /* [98] */
        }

        .products.list-view .product-controls { /* [267] */
             margin-top: auto;
        }


        .quantity-control {
            display: flex; /* [99] */
            align-items: center; /* [100] */
        }

        .qty-btn {
            width: 28px; /* [100] */
            height: 28px; /* [101] */
            border-radius: 50%; /* [101] */
            border: 1px solid var(--border-color); /* [101] */
            background-color: var(--bg-secondary); /* [101] */
            color: var(--text-color); /* [101] */
            display: flex; /* [101] */
            align-items: center; /* [101] */
            justify-content: center; /* [101] */
            cursor: pointer; /* [101] */
            transition: background-color 0.3s, transform 0.2s, box-shadow 0.3s; /* [102, 254] */
        }

        .qty-btn:hover {
            background-color: var(--primary-color); /* [102] */
            color: white; /* [103] */
        }

        .qty-input {
            width: 40px; /* [103] */
            text-align: center; /* [104] */
            border: none; /* [104] */
            background: transparent; /* [104] */
            color: var(--text-color); /* [104] */
            font-weight: bold; /* [104] */
            -moz-appearance: textfield;
        }
        .qty-input::-webkit-outer-spin-button,
        .qty-input::-webkit-inner-spin-button {
          -webkit-appearance: none;
          margin: 0;
        }

        .add-to-cart {
            padding: 6px 12px; /* [105] */
            border-radius: 50px; /* [106] */
            background-color: var(--primary-color); /* [106] */
            color: white; /* [106] */
            border: none; /* [106] */
            cursor: pointer; /* [106] */
            transition: background-color 0.3s, transform 0.2s, box-shadow 0.3s; /* [106, 254] */
            font-size: 0.85rem; /* [106] */
        }

        .add-to-cart:hover {
            background-color: var(--secondary-color); /* [107] */
        }

        .add-to-cart.in-cart {
            background-color: #27ae60; /* [108] */
        }

        /* --- Modais --- */
        .modal {
            display: none; /* [109] */
            position: fixed; /* [110] */
            z-index: 1000; /* [110] */
            left: 0; /* [110] */
            top: 0; /* [110] */
            width: 100%; /* [110] */
            height: 100%; /* [110] */
            background-color: var(--modal-overlay); /* [110] */
            justify-content: center; /* [110] */
            align-items: center; /* [110] */
            opacity: 0; /* [110] */
            transition: opacity 0.3s; /* [111] */
            overflow-y: auto; /* [111] */
        }

        .modal.active {
            opacity: 1; /* [111] */
        }

        .modal-content {
            position: relative; /* [112] */
            display: flex; /* [113] */
            flex-direction: column; /* [113] */
            align-items: center; /* [113] */
            max-width: 90%; /* [113] */
            max-height: 90%; /* [113] */
            background-color: var(--bg-secondary); /* [113] */
            border-radius: 8px; /* [113] */
            overflow: hidden; /* [113] */
            box-shadow: 0 5px 25px rgba(0, 0, 0, 0.2); /* [114] */
            margin: 20px; /* [114] */
            width: 800px; /* [114] */
        }

        .modal-header {
            width: 100%; /* [115] */
            padding: 15px 20px; /* [116] */
            background-color: var(--primary-color); /* [116] */
            color: white; /* [116] */
            display: flex; /* [116] */
            justify-content: space-between; /* [116] */
            align-items: center; /* [116] */
        }

        .modal-title {
            font-size: 1.2rem; /* [117] */
            font-weight: 600; /* [118] */
        }

        .modal-close {
            font-size: 24px; /* [118] */
            cursor: pointer; /* [119] */
        }

        .modal-body {
            width: 100%; /* [119] */
            padding: 20px; /* [120] */
            overflow-y: auto; /* [120] */
            max-height: 70vh; /* [120] */
        }

        /* Conteúdo específico dos modais */
        .image-modal-content {
            display: flex; /* [120] */
            flex-direction: column; /* [121] */
            align-items: center; /* [121] */
        }

        .image-modal-img {
            max-width: 100%; /* [121] */
            max-height: 60vh; /* [122] */
            object-fit: contain; /* [122] */
            margin-bottom: 20px; /* [122] */
        }

        .image-modal-info {
            width: 100%; /* [122] */
            text-align: center; /* [123] */
        }

        .collection-form {
            width: 100%; /* [123] */
        }

        .form-group {
            margin-bottom: 20px; /* [124] */
        }

        .form-group label {
            display: block; /* [125] */
            margin-bottom: 5px; /* [126] */
            font-weight: 500; /* [126] */
        }

        .form-group input, .form-group textarea, .form-group select {
            width: 100%; /* [126] */
            padding: 10px; /* [127] */
            border: 1px solid var(--border-color); /* [127] */
            border-radius: 4px; /* [127] */
            background-color: var(--bg-secondary); /* [127] */
            color: var(--text-color); /* [127] */
        }

        .form-group textarea {
            min-height: 100px; /* [128] */
            resize: vertical; /* [129] */
        }

        .collection-settings {
            margin-top: 20px; /* [129] */
            padding-top: 20px; /* [130] */
            border-top: 1px solid var(--border-color); /* [130] */
        }

        .settings-title {
            font-size: 1.1rem; /* [130] */
            font-weight: 600; /* [131] */
            margin-bottom: 15px; /* [131] */
        }

        .checkbox-group {
            display: flex; /* [131] */
            align-items: center; /* [132] */
            margin-bottom: 10px; /* [132] */
        }

        .checkbox-group label {
            margin-left: 10px; /* [132] */
            margin-bottom: 0; /* [133] */
        }

        .collections-list {
            list-style: none; /* [133] */
        }

        .collection-item {
            display: flex; /* [134] */
            justify-content: space-between; /* [135] */
            align-items: center; /* [135] */
            padding: 15px; /* [135] */
            border-bottom: 1px solid var(--border-color); /* [135] */
            transition: background-color 0.2s; /* [135] */
        }

        .collection-item:hover {
            background-color: var(--hover-color); /* [136] */
        }

        .collection-item-info {
            flex: 1; /* [137] */
        }

        .collection-item-name {
            font-weight: 600; /* [138] */
            font-size: 1.1rem; /* [139] */
        }

        .collection-item-meta {
            display: flex; /* [139] */
            gap: 20px; /* [140] */
            margin-top: 5px; /* [140] */
            font-size: 0.9rem; /* [140] */
            color: var(--text-secondary); /* [140] */
        }

        .collection-item-actions {
            display: flex; /* [140] */
            gap: 10px; /* [141] */
        }

        .collection-action-btn {
            padding: 5px 10px; /* [141] */
            border-radius: 4px; /* [142] */
            background-color: var(--primary-color); /* [142] */
            color: white; /* [142] */
            border: none; /* [142] */
            cursor: pointer; /* [142] */
            display: flex; /* [142] */
            align-items: center; /* [142] */
            justify-content: center; /* [142] */
            font-size: 0.9rem; /* [142] */
        }

        .collection-action-btn.edit {
            background-color: var(--primary-color); /* [143] */
        }
        .collection-action-btn.view { /* [385] */
             background-color: #2ecc71;
        }

        .collection-action-btn.pdf {
            background-color: #e74c3c; /* [144] */
        }

        .collection-action-btn.delete {
            background-color: #7f8c8d; /* [145] */
        }

        .collection-action-btn i {
            margin-right: 5px; /* [146] */
        }

        .cart-modal-content {
            width: 100%; /* [147] */
        }

        .cart-items {
            margin-bottom: 20px; /* [148] */
        }

        .cart-item {
            display: flex; /* [149] */
            justify-content: space-between; /* [150] */
            align-items: center; /* [150] */
            padding: 10px 0; /* [150] */
            border-bottom: 1px solid var(--border-color); /* [150] */
        }

        .cart-item-info {
            flex: 1; /* [151] */
        }

        .cart-item-name {
            font-weight: 600; /* [152] */
        }

        .cart-item-sku {
            font-size: 0.8rem; /* [153] */
            color: var(--text-secondary); /* [154] */
        }

        .cart-item-qty {
            display: flex; /* [154] */
            align-items: center; /* [155] */
            gap: 10px; /* [155] */
        }

        .cart-actions {
            display: flex; /* [155] */
            gap: 10px; /* [156] */
            margin-top: 20px; /* [156] */
        }

        .cart-action-btn {
            padding: 10px 20px; /* [156] */
            border-radius: 4px; /* [157] */
            background-color: var(--primary-color); /* [157] */
            color: white; /* [157] */
            border: none; /* [157] */
            cursor: pointer; /* [157] */
            transition: background-color 0.3s, transform 0.2s, box-shadow 0.3s; /* [157, 254] */
            flex: 1; /* [157] */
            display: flex; /* [157] */
            justify-content: center; /* [157] */
            align-items: center; /* [158] */
            gap: 5px; /* [158] */
        }

        .cart-action-btn.whatsapp {
            background-color: #25D366; /* [158] */
        }

        .cart-action-btn.clear {
            background-color: #e74c3c; /* [159] */
        }

        .cart-action-btn:hover { /* [160, 255] */
            opacity: 0.9;
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .modal-action-btns {
            display: flex; /* [161] */
            justify-content: flex-end; /* [162] */
            gap: 10px; /* [162] */
            margin-top: 20px; /* [162] */
        }

        .modal-btn {
            padding: 10px 20px; /* [162] */
            border-radius: 4px; /* [163] */
            border: none; /* [163] */
            font-weight: 500; /* [163] */
            cursor: pointer; /* [163] */
            transition: background-color 0.2s; /* [163] */
        }

        .modal-btn.cancel {
            background-color: #95a5a6; /* [164] */
            color: white; /* [165] */
        }

        .modal-btn.save {
            background-color: var(--accent-color); /* [165] */
            color: white; /* [166] */
        }

        .empty-cart-message, .empty-collections {
            text-align: center; /* [166] */
            padding: 50px 20px; /* [167] */
            color: var(--text-secondary); /* [167] */
        }

        .empty-collections i {
            font-size: 3rem; /* [167] */
            margin-bottom: 15px; /* [168] */
            opacity: 0.5; /* [168] */
        }

        /* PDF Preview styles */
        .pdf-settings {
            display: grid; /* [171] */
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); /* [172] */
            gap: 20px; /* [172] */
            margin-top: 20px; /* [172] */
        }

        .preview-section {
            margin-top: 30px; /* [172] */
            border-top: 1px solid var(--border-color); /* [173] */
            padding-top: 20px; /* [173] */
        }

        .preview-title {
            font-size: 1.1rem; /* [173] */
            font-weight: 600; /* [174] */
            margin-bottom: 15px; /* [174] */
        }

        .pdf-preview {
            width: 100%; /* [174] */
            max-width: 600px; /* [175] */
            margin: 0 auto; /* [175] */
            background-color: white; /* [175] */
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1); /* [175] */
            padding: 20px; /* [175] */
            border-radius: 4px; /* [175] */
        }

        .pdf-header {
            display: flex; /* [176] */
            justify-content: space-between; /* [177] */
            align-items: center; /* [177] */
            margin-bottom: 20px; /* [177] */
            padding-bottom: 10px; /* [177] */
            border-bottom: 2px solid #eee; /* [177] */
        }

        .pdf-logo {
            width: 150px; /* [178] */
            height: 50px; /* [179] */
            background-color: #eee; /* [179] */
            display: flex; /* [179] */
            align-items: center; /* [179] */
            justify-content: center; /* [179] */
            font-weight: bold; /* [179] */
        }

        .pdf-title {
            font-size: 1.2rem; /* [180] */
            font-weight: bold; /* [181] */
        }

        .pdf-products {
            display: grid; /* [181] */
            grid-template-columns: 1fr 1fr; /* [182] */
            gap: 15px; /* [182] */
        }

        .pdf-product {
            display: flex; /* [182] */
            background-color: #f9f9f9; /* [183] */
            border-radius: 4px; /* [183] */
            overflow: hidden; /* [183] */
        }

        .pdf-product-img {
            width: 80px; /* [183] */
            height: 80px; /* [184] */
            background-color: #eee; /* [184] */
            display: flex; /* [184] */
            align-items: center; /* [184] */
            justify-content: center; /* [184] */
        }

        .pdf-product-info {
            flex: 1; /* [185] */
            padding: 10px; /* [186] */
        }

        .pdf-product-sku {
            font-size: 0.8rem; /* [186] */
            color: #666; /* [187] */
        }

        .pdf-product-name {
            font-weight: 600; /* [187] */
            margin: 5px 0; /* [188] */
        }

        .pdf-price-field {
            margin-top: 5px; /* [188] */
            display: flex; /* [189] */
            align-items: center; /* [189] */
        }

        .pdf-price-label {
            width: 50px; /* [189] */
            font-size: 0.8rem; /* [190] */
        }

        .pdf-price-blank {
            flex: 1; /* [190] */
            height: 1px; /* [191] */
            background-color: #000; /* [191] */
            margin-left: 5px; /* [191] */
        }

        .pdf-price-value {
            font-weight: bold; /* [191] */
            color: var(--accent-color); /* [192] */
        }

        .pdf-footer {
            margin-top: 20px; /* [192] */
            padding-top: 10px; /* [193] */
            border-top: 1px solid #eee; /* [193] */
            font-size: 0.8rem; /* [193] */
            text-align: center; /* [193] */
            color: #999; /* [193] */
        }

        /* --- Outros Elementos --- */
        .loading-spinner {
            display: flex; /* [194] */
            align-items: center; /* [195] */
            justify-content: center; /* [195] */
            padding: 20px; /* [195] */
        }

        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1); /* [195] */
            border-left-color: var(--primary-color); /* [196] */
            border-radius: 50%; /* [196] */
            width: 30px; /* [196] */
            height: 30px; /* [196] */
            animation: spin 1s linear infinite; /* [196] */
        }

        @keyframes spin {
            to { transform: rotate(360deg); /* [197] */ }
        }

        .no-products {
            text-align: center; /* [198] */
            padding: 50px; /* [199] */
            background-color: var(--bg-secondary); /* [199] */
            border-radius: 8px; /* [199] */
            box-shadow: var(--card-shadow); /* [199] */
            font-size: 1.2rem; /* [199] */
            color: var(--text-secondary); /* [199] */
        }

        footer {
            background-color: var(--primary-color); /* [200] */
            color: white; /* [201] */
            text-align: center; /* [201] */
            padding: 20px 0; /* [201] */
            margin-top: 50px; /* [201] */
        }

        .back-to-top {
            position: fixed; /* [201] */
            bottom: 20px; /* [202] */
            right: 20px; /* [202] */
            width: 50px; /* [202] */
            height: 50px; /* [202] */
            border-radius: 50%; /* [202] */
            background-color: var(--primary-color); /* [202] */
            color: white; /* [202] */
            display: flex; /* [202] */
            align-items: center; /* [202] */
            justify-content: center; /* [202] */
            cursor: pointer; /* [203] */
            opacity: 0; /* [203] */
            visibility: hidden; /* [203] */
            transition: opacity 0.3s, visibility 0.3s; /* [203] */
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2); /* [203] */
            z-index: 100; /* [204] */
        }

        .back-to-top.visible {
            opacity: 1; /* [204] */
            visibility: visible; /* [205] */
        }

        .back-to-top:hover {
            background-color: var(--secondary-color); /* [205] */
        }

        .notifications {
            position: fixed; /* [206] */
            bottom: 20px; /* [207] */
            left: 20px; /* [207] */
            z-index: 1000; /* [207] */
        }

        .notification {
            padding: 15px 20px; /* [207] */
            color: white; /* [208] */
            border-radius: 4px; /* [208] */
            margin-bottom: 10px; /* [208] */
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1); /* [208] */
            display: flex; /* [208] */
            align-items: center; /* [208] */
            transform: translateY(100px); /* [208] */
            opacity: 0; /* [209] */
            transition: transform 0.3s, opacity 0.3s; /* [209] */
        }

        .notification.success {
            background-color: var(--success-color); /* [209] */
        }

        .notification.error {
            background-color: var(--error-color); /* [210] */
        }

        .notification.show {
            transform: translateY(0); /* [211] */
            opacity: 1; /* [212] */
        }

        .notification i {
            margin-right: 10px; /* [212] */
        }

        /* Progress Bar para PDF */
        .progress-container {
            width: 100%; /* [213] */
            margin-top: 15px; /* [214] */
            margin-bottom: 15px; /* [214] */
            display: none; /* [214] */
        }

        .progress-bar {
            width: 100%; /* [214] */
            height: 10px; /* [215] */
            background-color: #f0f0f0; /* [215] */
            border-radius: 5px; /* [215] */
            overflow: hidden; /* [215] */
        }

        .progress-fill {
            height: 100%; /* [215] */
            background-color: var(--accent-color); /* [216] */
            width: 0%; /* [216] */
            transition: width 0.3s ease; /* [216] */
        }

        .progress-text {
            text-align: center; /* [216] */
            margin-top: 5px; /* [217] */
            font-size: 0.9rem; /* [217] */
            color: var(--text-secondary); /* [217] */
        }

        /* Indicador de navegação por Swipe */
        .category-navigation-indicator { /* [291] */
             position: fixed;
             top: 50%;
             transform: translateY(-50%); /* [292] */
             background-color: rgba(52, 152, 219, 0.15);
             color: var(--primary-color);
             width: 40px;
             height: 80px;
             border-radius: 20px;
             display: flex;
             align-items: center;
             justify-content: center; /* [293] */
             opacity: 0;
             transition: opacity 0.3s, background-color 0.3s;
             pointer-events: none;
             z-index: 1000;
             backdrop-filter: blur(4px); /* [294] */
        }

        .category-navigation-indicator.active { /* [295] */
             opacity: 1;
             background-color: rgba(52, 152, 219, 0.7);
             color: white;
        }

         .category-navigation-indicator.left { /* [296] */
            left: 15px;
        }

         .category-navigation-indicator.right { /* [297] */
            right: 15px;
        }

        .category-title.active-category { /* [298] */
             border-bottom: 3px solid var(--primary-color);
             animation: categoryHighlight 0.8s ease;
        }

        @keyframes categoryHighlight { /* [299] */
             0% { background-color: rgba(52, 152, 219, 0); }
             50% { background-color: rgba(52, 152, 219, 0.2); /* [300] */ }
             100% { background-color: rgba(52, 152, 219, 0); /* [301] */ }
        }

        .swipe-hint { /* [302] */
             position: fixed;
             bottom: 30px;
             left: 50%;
             transform: translateX(-50%);
             background-color: rgba(52, 152, 219, 0.9);
             color: white;
             padding: 12px 24px;
             border-radius: 30px;
             font-size: 14px;
             display: flex; /* [303] */
             align-items: center;
             gap: 10px;
             box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
             z-index: 1000;
             pointer-events: none;
             animation: swipeHintPulse 2s infinite; /* [304] */
        }

         .swipe-hint i { /* [305] */
             font-size: 18px;
        }

        @keyframes swipeHintPulse { /* [306] */
             0% { transform: translateX(-50%) scale(1); }
             50% { transform: translateX(-50%) scale(1.05); }
             100% { transform: translateX(-50%) scale(1); /* [307] */ }
        }


        /* === RESPONSIVIDADE === */

        /* === MODIFICAÇÃO: ATUALIZAR VARIÁVEL BASE EM VEZ DE GRID-TEMPLATE-COLUMNS === */
        @media (min-width: 769px) and (max-width: 1024px) {
            :root {
                --coluna-produto-min-width-base: 200px; /* Define a base para este breakpoint */
            }
            /* REMOVIDO: .products { grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); } [274] */
        }

        @media (max-width: 768px) {
            :root {
                --coluna-produto-min-width-base: 160px; /* Define a base para este breakpoint */
            }
             /* REMOVIDO: .products { grid-template-columns: repeat(auto-fill, minmax(160px, 1fr)); } [270] */

            .vendor-controls {
                flex-direction: column; /* [217] */
                gap: 15px; /* [218] */
            }

            .collection-info {
                flex-direction: column; /* [218] */
                align-items: flex-start; /* [219] */
                gap: 10px; /* [219] */
            }

            .collection-actions {
                width: 100%; /* [219] */
                justify-content: space-between; /* [220] */
            }

            .filters, .filters-main {
                flex-direction: column; /* [220] */
                align-items: stretch; /* [221] */
            }

            .product-img-container {
                height: 140px; /* [222, 271] */
            }

            .product-actions { /* [223, 272] */
                opacity: 1;
                transform: translateY(0);
                top: 5px;
                right: 5px;
            }

            .product-action-btn { /* [273] */
                 width: 30px;
                 height: 30px;
            }

            .pdf-products {
                grid-template-columns: 1fr; /* [224] */
            }

            .cart-item {
                flex-direction: column; /* [225] */
                align-items: flex-start; /* [226] */
            }

            .cart-item-qty {
                margin-top: 10px; /* [226] */
            }

            .header-search { /* [243] */
                max-width: 100%;
                margin: 10px 0;
            }

        }

        @media (max-width: 576px) {
            :root {
                --coluna-produto-min-width-base: 105px; /* Define a base para este breakpoint */
            }
            /* REMOVIDO: .products { grid-template-columns: repeat(auto-fill, minmax(130px, 1fr)); } [229] */

            .header-controls {
                flex-direction: column; /* [227] */
                gap: 10px; /* [228] */
            }

            .product-img-container {
                height: 110px; /* [230] Ajustado de 130px */
            }

             .product-name { /* Exemplo de ajuste para colunas menores */
                font-size: 0.85rem; /* [91] */
                -webkit-line-clamp: 3;
            }

            .collection-item {
                flex-direction: column; /* [230] */
                align-items: flex-start; /* [231] */
            }

            .collection-item-actions {
                margin-top: 10px; /* [231] */
                width: 100%; /* [232] */
                justify-content: flex-end; /* [232] */
            }

            .cart-actions {
                flex-direction: column; /* [232] */
            }

            .pdf-settings {
                grid-template-columns: 1fr; /* [233] */
            }
        }
        /* === FIM DAS MODIFICAÇÕES DE RESPONSIVIDADE === */


        /* Estilos adicionais de presentation/fullscreen/novo modal podem vir aqui */
        /* ... (Se você adicionou esses estilos de respostas anteriores) ... */

    </style>
</head>
<body>
    <header>
        <div class="container">
            <h1>Catálogo de Produtos</h1>
            <div class="header-controls">
			
                <div class="theme-toggle" onclick="toggleTheme()">
                    <i class="fas fa-moon"></i>
                    <span>Modo Escuro</span>
                </div>
                <div class="mode-toggle" onclick="toggleMode()">
                    <i class="fas fa-shopping-cart"></i>
                    <span>Modo Cliente</span>
                </div>
                <div class="cart-indicator" onclick="openCartModal()">
                    <i class="fas fa-shopping-cart"></i>
                    <span>Carrinho</span>
                    <div class="cart-count">0</div>
                </div>
                <div class="collection-indicator" onclick="openManageCollectionsModal()">
                    <i class="fas fa-folder"></i>
                    <span>Coleções</span>
                    <div class="collection-count">0</div>
                </div>
            </div>
			
        </div>
		<div class="header-search">
    <div class="search-container">
        <i class="fas fa-search search-icon"></i>
        <input type="text" id="header-search" placeholder="Buscar por nome ou SKU (separe por vírgula)">
    </div>
</div>
    </header>

    <div class="container">
        <!-- Controles do Vendedor - Visível apenas no modo vendedor -->
        <div class="vendor-controls" style="display: none;">
            <div class="collection-info">
                <div class="collection-name">
                    <i class="fas fa-tags"></i>
                    <input type="text" placeholder="Nome da Coleção" id="collection-name">
                </div>
                <div class="selection-count">0 produtos selecionados</div>
            </div>
            <div class="collection-actions">
                <button class="vendor-btn save" onclick="openSaveCollectionModal()">
                    <i class="fas fa-save"></i> Salvar Coleção
                </button>
                <button class="vendor-btn pdf" onclick="openPdfModal()">
                    <i class="fas fa-file-pdf"></i> Gerar PDF
                </button>
                <button class="vendor-btn manage" onclick="openManageCollectionsModal()">
                    <i class="fas fa-folder-open"></i> Gerenciar Coleções
                </button>
            </div>
        </div>

        <div class="filters">
            <div class="filters-main">
                <div class="search-container">
                    <i class="fas fa-search search-icon"></i>
                    <input type="text" id="search" placeholder="Buscar por nome ou SKU">
                </div>
                <div class="select-container">
                    <select id="category">
                        <option value="">Todas as Categorias</option>
                    </select>
                    <i class="fas fa-chevron-down select-icon"></i>
                </div>
                <div class="select-container">
                    <select id="sort">
                        <option value="">Ordenação Padrão</option>
                        <option value="asc">Nome: A-Z</option>
                        <option value="desc">Nome: Z-A</option>
                    </select>
                    <i class="fas fa-chevron-down select-icon"></i>
                </div>
                <div class="filters-toggle" onclick="toggleAdvancedFilters()">
                    Filtros Avançados <i class="fas fa-chevron-down"></i>
                </div>
            </div>
            <div class="filters-advanced" id="advanced-filters">
                <div class="select-container">
                    <select id="package-size">
                        <option value="">Todos os Tamanhos</option>
                        <option value="500g">500g</option>
                        <option value="1kg">1kg</option>
                        <option value="4kg">4kg</option>
                        <option value="10kg">10kg</option>
                        <option value="12kg">12kg</option>
                        <option value="20kg">20kg</option>
                        <option value="25kg">25kg</option>
                    </select>
                    <i class="fas fa-chevron-down select-icon"></i>
                </div>
            </div>
        </div>
        
        <div class="loading-spinner" id="initial-loader">
            <div class="spinner"></div>
        </div>
        
        <div id="product-list"></div>
    </div>

    <!-- Modal para Imagem Ampliada -->
    <div id="imageModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">Visualização do Produto</div>
                <div class="modal-close" onclick="closeModal('imageModal')">&times;</div>
            </div>
            <div class="modal-body">
                <div class="image-modal-content">
                    <img class="image-modal-img" id="modalImg" src="" alt="Imagem Ampliada">
                    <div class="image-modal-info" id="modalProductInfo"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal para Carrinho -->
    <div id="cartModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">Carrinho de Produtos</div>
                <div class="modal-close" onclick="closeModal('cartModal')">&times;</div>
            </div>
            <div class="modal-body">
                <div class="cart-modal-content">
                    <div class="cart-items" id="cart-items">
                        <!-- Itens do carrinho serão adicionados aqui -->
                    </div>
                    <div class="cart-actions">
                        <button class="cart-action-btn whatsapp" onclick="sendToWhatsApp()">
                            <i class="fab fa-whatsapp"></i> Enviar para WhatsApp
                        </button>
                        <button class="cart-action-btn clear" onclick="clearCart()">
                            <i class="fas fa-trash"></i> Limpar Carrinho
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal para Salvar Coleção -->
    <div id="saveCollectionModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">Salvar Coleção</div>
                <div class="modal-close" onclick="closeModal('saveCollectionModal')">&times;</div>
            </div>
            <div class="modal-body">
                <div class="collection-form">
                    <div class="form-group">
                        <label for="save-collection-name">Nome da Coleção</label>
                        <input type="text" id="save-collection-name" placeholder="Ex: Produtos para Padaria XYZ">
                    </div>
                    <div class="form-group">
                        <label for="collection-description">Descrição (opcional)</label>
                        <textarea id="collection-description" placeholder="Adicione uma descrição para esta coleção..."></textarea>
                    </div>
                    <div class="collection-settings">
                        <h3 class="settings-title">Configurações da Coleção</h3>
                        <div class="checkbox-group">
                            <input type="checkbox" id="save-as-default">
                            <label for="save-as-default">Manter estes produtos selecionados após salvar</label>
                        </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="include-prices" checked>
                            <label for="include-prices">Salvar preços dos produtos</label>
                        </div>
                    </div>
                    <div class="modal-action-btns">
                        <button class="modal-btn cancel" onclick="closeModal('saveCollectionModal')">Cancelar</button>
                        <button class="modal-btn save" onclick="saveCollection()">Salvar Coleção</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal para Gerenciar Coleções -->
    <div id="manageCollectionsModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">Gerenciar Coleções</div>
                <div class="modal-close" onclick="closeModal('manageCollectionsModal')">&times;</div>
            </div>
            <div class="modal-body">
                <div id="collections-container">
                    <!-- O conteúdo das coleções será carregado aqui -->
                </div>
            </div>
        </div>
    </div>

    <!-- Modal para gerar PDF -->
    <div id="pdfModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">Gerar PDF da Coleção</div>
                <div class="modal-close" onclick="closeModal('pdfModal')">&times;</div>
            </div>
            <div class="modal-body">
                <div class="collection-form">
                    <div class="form-group">
                        <label for="pdf-collection-name">Título do PDF</label>
                        <input type="text" id="pdf-collection-name" placeholder="Ex: Catálogo para Cliente XYZ">
                    </div>
                    
                    <div class="pdf-settings">
                        <div class="form-group">
                            <label>Elementos a incluir:</label>
                            <div class="checkbox-group">
                                <input type="checkbox" id="include-sku" checked>
                                <label for="include-sku">Código do Produto (SKU)</label>
                            </div>
                            <div class="checkbox-group">
                                <input type="checkbox" id="include-category" checked>
                                <label for="include-category">Categoria</label>
                            </div>
                            <div class="checkbox-group">
                                <input type="checkbox" id="include-price" checked>
                                <label for="include-price">Preços definidos</label>
                            </div>
                            <div class="checkbox-group">
                                <input type="checkbox" id="include-price-field" checked>
                                <label for="include-price-field">Campo para preço manual</label>
                            </div>
                        </div>
                        
                        <div class="form-group">
                            <label>Layout do PDF:</label>
                            <div class="checkbox-group">
                                <input type="checkbox" id="group-by-category" checked>
                                <label for="group-by-category">Agrupar por categoria</label>
                            </div>
                            <div class="checkbox-group">
                                <input type="checkbox" id="include-logo" checked>
                                <label for="include-logo">Incluir logo da empresa</label>
                            </div>
                            <div class="checkbox-group">
                                <input type="checkbox" id="include-images" checked>
                                <label for="include-images">Incluir imagens dos produtos</label>
                            </div>
                            <div class="checkbox-group">
                                <input type="checkbox" id="include-footer" checked>
                                <label for="include-footer">Incluir rodapé com informações de contato</label>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Barra de Progresso para PDF -->
                    <div class="progress-container" id="pdf-progress-container">
                        <div class="progress-bar">
                            <div class="progress-fill" id="pdf-progress-fill"></div>
                        </div>
                        <div class="progress-text" id="pdf-progress-text">Carregando imagens: 0%</div>
                    </div>
                    
                    <div class="preview-section">
                        <h3 class="preview-title">Pré-visualização</h3>
                        <div class="pdf-preview">
                            <div class="pdf-header">
                                <div class="pdf-logo">AMERIPAN</div>
                                <div class="pdf-title">Catálogo de Produtos</div>
                            </div>
                            <div class="pdf-products">
                                <div class="pdf-product">
                                    <div class="pdf-product-img">IMG</div>
                                    <div class="pdf-product-info">
                                        <div class="pdf-product-sku">SKU: ABC123</div>
                                        <div class="pdf-product-name">Chocolate Premium 1kg</div>
                                        <div class="pdf-price-field">
                                            <div class="pdf-price-label">Preço:</div>
                                            <div class="pdf-price-value">R$ 25,90</div>
                                        </div>
                                    </div>
                                </div>
                                <div class="pdf-product">
                                    <div class="pdf-product-img">IMG</div>
                                    <div class="pdf-product-info">
                                        <div class="pdf-product-sku">SKU: DEF456</div>
                                        <div class="pdf-product-name">Granulado Colorido 500g</div>
                                        <div class="pdf-price-field">
                                            <div class="pdf-price-label">Preço:</div>
                                            <div class="pdf-price-blank"></div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="pdf-footer">
                                www.ameripan.com.br | atendimento@ameripan.com.br | (19) 3406-4070
                            </div>
                        </div>
                    </div>
                    
                    <div class="modal-action-btns">
                        <button class="modal-btn cancel" onclick="closeModal('pdfModal')">Cancelar</button>
                        <button class="modal-btn save" id="generate-pdf-btn" onclick="generatePDF()">Gerar PDF</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="back-to-top" id="backToTop" onclick="scrollToTop()">
        <i class="fas fa-arrow-up"></i>
    </div>

    <div class="notifications" id="notifications">
        <!-- Notificações serão adicionadas aqui -->
    </div>

    <footer>
        <div class="container">
            <p>&copy; 2025 Catálogo de Produtos Ameripan</p>
        </div>
    </footer>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.25/jspdf.plugin.autotable.min.js"></script>
    <script>
        // Configurações para o Google Sheets
const GOOGLE_SHEETS_CONFIG = {
    spreadsheetId: "1mqPdLr8nlOG6VCsLCbDuIadvTrl3cCwO1n3fMnjXInw", // ID da planilha
    apiKey: "AIzaSyB_DqAfjDQHOGESUrUboqiVYv0qGa1WeJc", // Chave API
    range: "produtos" // Nome da aba/planilha (ajuste conforme sua estrutura)
};

// Variáveis para controle de carregamento
let productData = [];
let allProducts = [];
let visibleProducts = 40;  // Aumento do valor inicial para mais produtos na primeira carga
const incrementAmount = 30; // Aumentado para carregar mais produtos por vez
let isLoading = false;
let scrollThreshold = 200; // Distância em pixels do final da página para começar a carregar mais

///

let cart = JSON.parse(localStorage.getItem('cart')) || [];

// Coleções
let collections = JSON.parse(localStorage.getItem('collections')) || [];
let selectedProducts = JSON.parse(localStorage.getItem('selectedProducts')) || [];

// Configuração do modo vendedor/cliente
let inVendorMode = localStorage.getItem('vendorMode') === 'true' || false;

// Cache de imagens global para persistência entre sessões
let globalImageCache = new Map();

// Estado atual de processamento do PDF
let pdfGenerationState = {
    inProgress: false,
    processedItems: 0,
    totalItems: 0,
    sessionId: null,
    imageCache: null,
    retryCount: {}
};

// Nova variável para controle do filtro de coleção
let activeCollectionFilter = null;

// Mostrar loader inicial
document.getElementById('initial-loader').style.display = 'flex';

// Inicializar a página
document.addEventListener('DOMContentLoaded', () => {
    fetchGoogleSheetsData();
    updateCartCount();
    setupTheme();
    updateCollectionCount();
    updateSelectionCount();
    
    // Aplicar modo salvo (cliente ou vendedor)
    applyCurrentMode();
    
    // Tentar recuperar cache de imagens de uma sessão anterior
    const savedImageCache = localStorage.getItem('imageCache');
    if (savedImageCache) {
        try {
            const cacheData = JSON.parse(savedImageCache);
            // Reconstruir o Map a partir dos dados JSON
            globalImageCache = new Map(Object.entries(cacheData));
            console.log(`Cache de imagens recuperado com ${globalImageCache.size} itens`);
        } catch (e) {
            console.warn("Não foi possível recuperar o cache de imagens:", e);
            globalImageCache = new Map();
        }
    }
    
    // Adicionar estilos CSS necessários para o novo botão
    const styleElement = document.createElement('style');
    styleElement.textContent = `
        .collection-action-btn.view {
            background-color: #2ecc71;
        }
    `;
    document.head.appendChild(styleElement);
});

// Aplicar o modo atual (cliente ou vendedor)
function applyCurrentMode() {
    if (inVendorMode) {
        document.querySelector('.mode-toggle').innerHTML = '<i class="fas fa-shopping-cart"></i><span>Modo Cliente</span>';
        document.querySelector('.vendor-controls').style.display = 'flex';
    } else {
        document.querySelector('.mode-toggle').innerHTML = '<i class="fas fa-user"></i><span>Modo Vendedor</span>';
        document.querySelector('.vendor-controls').style.display = 'none';
    }
}

// Configurar tema (claro/escuro)
function setupTheme() {
    const savedTheme = localStorage.getItem('theme') || 'light';
    document.documentElement.setAttribute('data-theme', savedTheme);
    updateThemeToggle(savedTheme);
}

function toggleTheme() {
    const currentTheme = document.documentElement.getAttribute('data-theme');
    const newTheme = currentTheme === 'light' ? 'dark' : 'light';
    
    document.documentElement.setAttribute('data-theme', newTheme);
    localStorage.setItem('theme', newTheme);
    updateThemeToggle(newTheme);
}

function updateThemeToggle(theme) {
    const themeToggle = document.querySelector('.theme-toggle');
    
    if (theme === 'dark') {
        themeToggle.innerHTML = '<i class="fas fa-sun"></i><span>Modo Claro</span>';
    } else {
        themeToggle.innerHTML = '<i class="fas fa-moon"></i><span>Modo Escuro</span>';
    }
}

// Alternar entre modo cliente e vendedor
function toggleMode() {
    inVendorMode = !inVendorMode;
    
    // Salvar a configuração
    localStorage.setItem('vendorMode', inVendorMode);
    
    // Aplicar o modo selecionado
    applyCurrentMode();
    
    // Reexibir produtos para atualizar a interface
    displayProducts();
}

// Controle de filtros avançados
function toggleAdvancedFilters() {
    const filtersAdvanced = document.getElementById('advanced-filters');
    const toggleButton = document.querySelector('.filters-toggle');
    
    if (filtersAdvanced.style.display === 'flex') {
        filtersAdvanced.style.display = 'none';
        toggleButton.classList.remove('active');
    } else {
        filtersAdvanced.style.display = 'flex';
        toggleButton.classList.add('active');
    }
}

// Função para buscar dados do Google Sheets
async function fetchGoogleSheetsData() {
    try {
        // Mostrar loader inicial
        document.getElementById('initial-loader').style.display = 'flex';
        
        const { spreadsheetId, apiKey, range } = GOOGLE_SHEETS_CONFIG;
        const url = `https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}/values/${range}?key=${apiKey}`;
        
        console.log("Buscando dados do Google Sheets:", url);
        
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(`Erro ao buscar dados do Google Sheets: ${response.status} ${response.statusText}`);
        }
        
        const data = await response.json();
        console.log("Dados recebidos do Google Sheets:", data);
        
        // Processar os dados da planilha
        processGoogleSheetsData(data.values);
    } catch (error) {
        console.error("Erro ao carregar dados do Google Sheets:", error);
        
        // Tentar carregar dados de exemplo como fallback
        try {
            console.log("Tentando carregar dados de exemplo");
            const exampleData = generateExampleData();
            parseExampleData(exampleData);
        } catch (fallbackError) {
            console.error("Erro ao gerar dados de exemplo:", fallbackError);
            document.getElementById('initial-loader').style.display = 'none';
            document.getElementById('product-list').innerHTML = `
                <div class="no-products">
                    <p>Erro ao carregar os produtos: ${error.message}</p>
                    <p>Verifique se a planilha do Google Sheets está acessível ou carregue um arquivo manualmente.</p>
                    <input type="file" id="csv-file-input" accept=".csv" style="margin-top: 20px;" 
                           onchange="handleFileUpload(event)" />
                </div>
            `;
        }
    }
}

// Função para processar os dados recebidos do Google Sheets - versão completa e atualizada
function processGoogleSheetsData(values) {
    try {
        if (!values || values.length <= 1) {
            console.error("Não há dados na planilha ou apenas o cabeçalho está presente");
            showNotification("Não há dados na planilha ou apenas o cabeçalho está presente", "error");
            return;
        }
        
        console.log(`Processando ${values.length - 1} linhas de dados da planilha...`);
        
        // A primeira linha contém os cabeçalhos
        const headers = values[0];
        console.log("Cabeçalhos encontrados:", headers);
        
        // Encontrar os índices das colunas necessárias
        const rowIdIndex = headers.indexOf("rowid");
        const categoriaIndex = headers.indexOf("categoria");
        const skuIndex = headers.indexOf("sku");
        const marcaIndex = headers.indexOf("marca");
        const imgIndex = headers.indexOf("img");
        
        // Verificar se todas as colunas necessárias foram encontradas
        if (categoriaIndex === -1 || skuIndex === -1 || marcaIndex === -1) {
            console.error("Colunas necessárias não encontradas na planilha.", {
                categoria: categoriaIndex !== -1,
                sku: skuIndex !== -1,
                marca: marcaIndex !== -1
            });
            
            showNotification("Estrutura da planilha incorreta. Verifique se existem as colunas: categoria, sku, marca", "error");
            return;
        }
        
        // Array temporário para os produtos
        const tempProducts = [];
        
        // Agora usamos um Set para detectar combinações únicas de SKU+categoria
        // em vez de apenas SKUs únicos
        const processedSkuCategoryPairs = new Set();
        const processedRows = { total: 0, valid: 0, duplicates: 0, invalid: 0, imageIssues: 0 };
        
        // Processar cada linha de dados (pulando o cabeçalho)
        for (let i = 1; i < values.length; i++) {
            try {
                processedRows.total++;
                const row = values[i];
                
                // Extrair os valores da linha (com validação)
                const rowid = rowIdIndex !== -1 && row[rowIdIndex] ? row[rowIdIndex].toString() : i.toString();
                const categoria = categoriaIndex !== -1 && row[categoriaIndex] ? row[categoriaIndex].toString().trim() : "";
                const sku = skuIndex !== -1 && row[skuIndex] ? row[skuIndex].toString().trim() : "";
                const marca = marcaIndex !== -1 && row[marcaIndex] ? row[marcaIndex].toString().trim() : "";
                
                // Processar URL da imagem com validação
                let img = "";
                if (imgIndex !== -1 && row[imgIndex]) {
                    img = row[imgIndex].toString().trim();
                    // Validar e corrigir URL de imagem
                    img = validateImageUrl(img);
                    
                    // Registrar problema se a URL original estava vazia ou foi substituída por um placeholder
                    if (!row[imgIndex] || row[imgIndex].toString().trim() === "" || img.includes("placeholder.com")) {
                        processedRows.imageIssues++;
                    }
                } else {
                    // Sem URL de imagem fornecida
                    img = `https://via.placeholder.com/300x300?text=${encodeURIComponent(`Produto ${sku}`)}`;
                    processedRows.imageIssues++;
                }
                
                // Pular linhas sem dados essenciais
                if (!categoria || !sku || !marca) {
                    console.warn(`Linha ${i+1} ignorada por falta de dados essenciais:`, { categoria, sku, marca });
                    processedRows.invalid++;
                    continue;
                }
                
                // Criar uma chave única para a combinação de SKU e categoria
                const skuCategoryKey = `${sku}-${categoria}`;
                
                // Verificar se já processamos este par de SKU+categoria
                if (sku && !processedSkuCategoryPairs.has(skuCategoryKey)) {
                    // Marcar esta combinação como processada
                    processedSkuCategoryPairs.add(skuCategoryKey);
                    
                    // Extrair informação de tamanho da embalagem (se existir)
                    let packageSize = extractPackageSize(marca);
                    
                    // Adicionar o produto
                    tempProducts.push({ 
                        rowid, 
                        categoria, 
                        sku, 
                        marca, 
                        img, 
                        packageSize,
                        price: '' // Campo para preço no modo vendedor
                    });
                    
                    processedRows.valid++;
                } else {
                    // Produto duplicado (mesmo SKU e categoria)
                    processedRows.duplicates++;
                }
            } catch (rowError) {
                console.error(`Erro ao processar linha ${i+1}:`, rowError);
                processedRows.invalid++;
            }
        }
        
        // Registrar estatísticas
        console.log("Estatísticas de processamento:", processedRows);
        
        // Atualizar o array global de produtos
        allProducts = tempProducts;
        
        // Ordenar produtos por categoria e nome
        allProducts.sort((a, b) => {
            if (a.categoria !== b.categoria) {
                return a.categoria.localeCompare(b.categoria);
            }
            return a.marca.localeCompare(b.marca);
        });
        
        // Ocultar loader inicial
        document.getElementById('initial-loader').style.display = 'none';
        
        // Popular categorias e exibir produtos
        populateCategories();
        displayProducts();
        
        // Configurar observador para scroll infinito
        setupInfiniteScroll();
        
        // Mostrar notificação de sucesso
        if (typeof showNotification === 'function') {
            let message = `${allProducts.length} produtos carregados com sucesso!`;
            
            // Adicionar aviso se houver problemas com imagens
            if (processedRows.imageIssues > 0) {
                message += ` (${processedRows.imageIssues} com problemas de imagem)`;
            }
            
            showNotification(message, 'success');
            
            // Mostrar alerta adicional se houver muitos problemas de imagem
            if (processedRows.imageIssues > allProducts.length * 0.3) { // Se mais de 30% tem problemas
                setTimeout(() => {
                    showNotification('Verifique as URLs de imagem na planilha. Muitas estão ausentes ou incorretas.', 'error');
                }, 2000);
            }
        }
        
        // Guardar estatísticas para diagnóstico
        window.sheetsProcessingStats = processedRows;
        
    } catch (error) {
        console.error("Erro durante o processamento dos dados da planilha:", error);
        document.getElementById('initial-loader').style.display = 'none';
        showNotification("Erro ao processar os dados: " + error.message, "error");
    }
}

// Função auxiliar para verificar e corrigir URLs de imagem
function validateImageUrl(url) {
    if (!url || typeof url !== 'string' || url.trim() === '') {
        return "https://via.placeholder.com/300x300?text=Imagem+Indisponível";
    }
    
    // Se a URL não começar com http:// ou https://, adicionar https://
    if (!url.startsWith('http://') && !url.startsWith('https://')) {
        return 'https://' + url;
    }
    
    return url;
}




// Extrai informação de tamanho da embalagem
function extractPackageSize(name) {
    const patterns = [
        /\b500g\b/i,
        /\b1\s*kg\b/i,
        /\b4\s*kg\b/i,
        /\b10\s*kg\b/i,
        /\b12\s*kg\b/i,
        /\b20\s*kg\b/i,
        /\b25\s*kg\b/i
    ];
    
    const sizes = ['500g', '1kg', '4kg', '10kg', '12kg', '20kg', '25kg'];
    
    for (let i = 0; i < patterns.length; i++) {
        if (patterns[i].test(name)) {
            return sizes[i];
        }
    }
    
    return null;
}

// Exibir produtos com filtros aplicados
// Versão otimizada de displayProducts que mantém os produtos já exibidos
function displayProducts(filter = "", category = "", sort = "", packageSize = "") {
    // Obter valores dos filtros dos campos de entrada se não forem fornecidos
    filter = filter || document.getElementById("search")?.value || "";
    category = category || document.getElementById("category")?.value || "";
    sort = sort || document.getElementById("sort")?.value || "";
    packageSize = packageSize || document.getElementById("package-size")?.value || "";
    
    // Resetar variáveis de controle quando mudamos os filtros
    if (filter || category || sort || packageSize) {
        visibleProducts = 40; // Voltar ao valor inicial ao filtrar
        window.preloadedElements = {}; // Limpar cache de elementos
    }
    
    // Filtrar produtos de acordo com critérios
    productData = allProducts.filter(p => {
        // Processar múltiplos termos de filtro separados por vírgula
        const filterTerms = filter.split(',')
            .map(term => term.trim().toLowerCase())
            .filter(term => term.length > 0);

        // Filtro por texto (nome ou SKU) - agora suporta múltiplos termos
        const textMatch = filterTerms.length === 0 || 
            filterTerms.some(term => 
                p.marca.toLowerCase().includes(term) || 
                p.sku.toLowerCase().includes(term)
            );
        
        // Filtro por categoria
        const categoryMatch = !category || p.categoria === category;
        
        // Filtro por tamanho da embalagem
        const packageMatch = !packageSize || 
            (p.packageSize && p.packageSize.toLowerCase() === packageSize.toLowerCase());
        
        // Filtro de coleção ativa
        const collectionMatch = !activeCollectionFilter || 
            activeCollectionFilter.skus.includes(p.sku);
        
        return textMatch && categoryMatch && packageMatch && collectionMatch;
    });
    
    // Aplicar ordenação
    if (sort) {
        productData.sort((a, b) => {
            if (sort === 'asc') {
                return a.marca.localeCompare(b.marca);
            } else if (sort === 'desc') {
                return b.marca.localeCompare(a.marca);
            }
            return 0;
        });
    } else {
        // Ordenação padrão: por categoria depois por nome
        productData.sort((a, b) => {
            if (a.categoria !== b.categoria) {
                return a.categoria.localeCompare(b.categoria);
            }
            return a.marca.localeCompare(b.marca);
        });
    }
    
    let productList = document.getElementById("product-list");
    productList.innerHTML = "";
    
    if (productData.length === 0) {
        productList.innerHTML = '<div class="no-products">Nenhum produto encontrado com os critérios de busca.</div>';
        return;
    }
    
    // Limitar ao número de produtos visíveis
    const visibleData = productData.slice(0, visibleProducts);
    
    // Agrupar por categoria
    let categories = [...new Set(visibleData.map(p => p.categoria))].sort();
    
    // Criar um fragmento para todas as categorias (reduz reflow)
    const mainFragment = document.createDocumentFragment();
    
    categories.forEach(cat => {
        let categorySection = document.createElement("div");
        categorySection.classList.add("category-section");
        categorySection.setAttribute('data-category', cat);
        
        // Adicionar título da categoria e botão para selecionar todos
        let categorySelectorHtml = '';
        if (inVendorMode) {
            categorySelectorHtml = `
                <div class="category-selection">
                    <button class="select-all-cat" onclick="toggleCategorySelection('${cat}')">Selecionar Todos</button>
                </div>
            `;
        }
        
        categorySection.innerHTML = `
            <h2 class="category-title">
                ${cat}
                ${categorySelectorHtml}
            </h2>
        `;
        
        let productContainer = document.createElement("div");
        productContainer.classList.add("products");
        
        // Aplicar modo de visualização atual (grid/lista)
        if (typeof window.isGridView !== 'undefined' && !window.isGridView) {
            productContainer.classList.add("list-view");
        }
        
        // Criar um fragmento para os produtos desta categoria
        const categoryFragment = document.createDocumentFragment();
        
        visibleData
            .filter(p => p.categoria === cat)
            .forEach(p => {
                // Criar elemento do produto
                const productElement = createProductElement(p);
                categoryFragment.appendChild(productElement);
            });
        
        // Adicionar todos os produtos de uma vez (operação DOM única)
        productContainer.appendChild(categoryFragment);
        categorySection.appendChild(productContainer);
        mainFragment.appendChild(categorySection);
    });
    
    // Adicionar todas as categorias ao DOM de uma vez
    productList.appendChild(mainFragment);
    
    // Verificar se precisamos mostrar o loader para carregamento infinito
    addInfiniteScrollLoader();
    
    // Iniciar pré-carregamento silencioso
    setTimeout(() => {
        if (productData.length > visibleProducts) {
            preloadNextBatch();
        }
    }, 500);
}

///novas functions


// Função para debugar problemas de imagem
function debugImageIssues() {
    console.log("Verificando problemas de imagem...");
    
    // Contar e verificar problemas
    let totalImages = 0;
    let emptyUrlCount = 0;
    let invalidUrlCount = 0;
    let brokenImages = document.querySelectorAll('img[src=""]').length;
    
    // Analisar URLs de imagens nos produtos
    allProducts.forEach(product => {
        totalImages++;
        if (!product.img || product.img.trim() === '') {
            emptyUrlCount++;
            console.warn(`Produto SKU ${product.sku} tem URL de imagem vazia`);
        } else if (!product.img.startsWith('http://') && !product.img.startsWith('https://')) {
            invalidUrlCount++;
            console.warn(`Produto SKU ${product.sku} tem URL de imagem sem protocolo: ${product.img}`);
        }
    });
    
    console.log(`Análise completa: ${totalImages} imagens no total`);
    console.log(`${emptyUrlCount} URLs vazias, ${invalidUrlCount} URLs sem protocolo, ${brokenImages} imagens quebradas no DOM`);
    
    // Mostrar notificação para o usuário
    if (typeof showNotification === 'function') {
        if (emptyUrlCount > 0 || invalidUrlCount > 0) {
            showNotification(`Atenção: ${emptyUrlCount + invalidUrlCount} produtos com problemas nas URLs de imagem`, 'error');
        } else {
            showNotification('Nenhum problema encontrado nas URLs de imagem', 'success');
        }
    }
}

// Função corrigida para criar elemento de produto (foco nas imagens)
function createProductElement(p) {
    // Verificar se o produto está selecionado
    const isSelected = selectedProducts.some(item => item.sku === p.sku);
    
    // Verificar se o produto está no carrinho
    const inCart = cart.some(item => item.sku === p.sku);
    const cartItem = cart.find(item => item.sku === p.sku);
    const quantity = cartItem ? cartItem.quantity : 0;
    
    // Obter preço do produto (no modo vendedor)
    const selectedProduct = selectedProducts.find(item => item.sku === p.sku);
    const productPrice = selectedProduct ? selectedProduct.price || '' : '';
    
    let productDiv = document.createElement("div");
    productDiv.classList.add("product");
    if (isSelected) {
        productDiv.classList.add("selected");
    }
    productDiv.setAttribute('data-rowid', p.rowid);
    productDiv.setAttribute('data-sku', p.sku);
    
    // Processar URL da imagem com mais cuidado
    let imgSrc = p.img || '';
    // Garantir que a URL seja válida (não vazia e tenha um formato de URL)
    if (!imgSrc || imgSrc.trim() === '') {
        imgSrc = "https://via.placeholder.com/300x300?text=Produto+Indisponível";
    }
    
    const imgHighRes = imgSrc.includes('300x300') ? imgSrc.replace('300x300', '2500x2500') : imgSrc;
    
    // Botão de seleção para modo vendedor
    let selectionButton = '';
    if (inVendorMode) {
        selectionButton = `
            <div class="product-select" onclick="toggleProductSelection('${p.sku}', '${p.marca.replace(/'/g, "\\'")}', '${p.categoria}', '${imgSrc}')">
                ${isSelected ? '<i class="fas fa-check"></i>' : ''}
            </div>
        `;
    }
    
    // Conteúdo da imagem e informações básicas do produto
    // Removido o atributo loading="lazy" para compatibilidade
    let productContent = `
        <div class="product-img-container">
            <img src="${imgSrc}" alt="${p.marca}" 
                 onclick="openImageModal('${imgHighRes}', '${p.sku}', '${p.marca.replace(/'/g, "\\'")}')"
                 onerror="handleImageError(this, '${p.sku}')">
            ${selectionButton}
            <div class="product-actions">
                <div class="product-action-btn" onclick="openImageModal('${imgHighRes}', '${p.sku}', '${p.marca.replace(/'/g, "\\'")}')">
                    <i class="fas fa-search-plus"></i>
                </div>
            </div>
        </div>
        <div class="product-info">
            <span class="product-sku">${p.sku}</span>
            <h3 class="product-name">${p.marca}</h3>
            <span class="product-category">${p.categoria}</span>
            ${p.packageSize ? `<span class="product-package">${p.packageSize}</span>` : ''}
    `;
    
    // Adicionar campo de preço no modo vendedor para produtos selecionados
    if (inVendorMode && isSelected) {
        productContent += `
            <div class="price-input-group">
                <span class="currency-symbol">R$</span>
                <input type="text" class="product-price-input" 
                       placeholder="Insira o preço" 
                       value="${productPrice}"
                       onchange="updateProductPrice('${p.sku}', this.value)">
            </div>
        `;
    }
    
    // Controles de carrinho (apenas no modo cliente ou para ambos os modos)
    if (!inVendorMode || (inVendorMode && true)) { // Permitir carrinho no modo vendedor também
        productContent += `
            <div class="product-controls">
                <div class="quantity-control">
                    <button class="qty-btn" onclick="decrementQuantity('${p.sku}')">-</button>
                    <input type="number" class="qty-input" id="qty-${p.sku}" value="${quantity}" min="0" max="999" readonly>
                    <button class="qty-btn" onclick="incrementQuantity('${p.sku}')">+</button>
                </div>
                <button class="add-to-cart ${inCart ? 'in-cart' : ''}" 
                        id="cart-btn-${p.sku}" 
                        onclick="toggleCart('${p.sku}', '${p.marca.replace(/'/g, "\\'")}', '${p.categoria}')">
                    ${inCart ? '<i class="fas fa-check"></i>' : '<i class="fas fa-cart-plus"></i>'}
                </button>
            </div>
        `;
    }
    
    productContent += `</div>`; // Fechando product-info
    
    productDiv.innerHTML = productContent;
    return productDiv;
}

// Pré-carregar o próximo lote de produtos sem mostrar ao usuário
function preloadNextBatch() {
    // Verificar se já estamos carregando ou se não há mais produtos
    if (isLoading || productData.length <= visibleProducts) return;
    
    // Calcular quantos produtos pré-carregar
    let preloadAmount = Math.min(incrementAmount, productData.length - visibleProducts);
    
    if (preloadAmount <= 0) return;
    
    // Marcar como carregamento em progresso
    isLoading = true;
    
    // Criar elementos DOM para os próximos produtos mas não inserir na página ainda
    const preloadedItems = [];
    const fragment = document.createDocumentFragment();
    
    // Encontrar produtos por categoria para criar a estrutura adequada
    const preloadStart = visibleProducts;
    const preloadEnd = preloadStart + preloadAmount;
    
    // Agrupar produtos por categoria
    const categoriesMap = {};
    
    for (let i = preloadStart; i < preloadEnd && i < productData.length; i++) {
        const product = productData[i];
        if (!categoriesMap[product.categoria]) {
            categoriesMap[product.categoria] = [];
        }
        categoriesMap[product.categoria].push(product);
    }
    
    // Armazenar elementos pré-carregados em cache de memória
    window.preloadedElements = window.preloadedElements || {};
    
    // Criar elementos para cada categoria, mas não adicioná-los ainda
    for (const category in categoriesMap) {
        if (!window.preloadedElements[category]) {
            window.preloadedElements[category] = {
                container: null,
                products: []
            };
            
            // Verificar se a seção da categoria já existe
            let categorySection = document.querySelector(`.category-section[data-category="${category}"]`);
            
            if (!categorySection) {
                // Se não existir, criar uma nova seção
                categorySection = document.createElement("div");
                categorySection.classList.add("category-section");
                categorySection.setAttribute('data-category', category);
                
                // Adicionar título da categoria e botão para selecionar todos
                let categorySelectorHtml = '';
                if (inVendorMode) {
                    categorySelectorHtml = `
                        <div class="category-selection">
                            <button class="select-all-cat" onclick="toggleCategorySelection('${category}')">Selecionar Todos</button>
                        </div>
                    `;
                }
                
                categorySection.innerHTML = `
                    <h2 class="category-title">
                        ${category}
                        ${categorySelectorHtml}
                    </h2>
                `;
                
                // Criar container de produtos
                const productContainer = document.createElement("div");
                productContainer.classList.add("products");
                if (!window.isGridView) {
                    productContainer.classList.add("list-view");
                }
                
                categorySection.appendChild(productContainer);
                window.preloadedElements[category].container = categorySection;
            } else {
                // Se a seção já existe, usar o container existente
                window.preloadedElements[category].container = categorySection;
            }
        }
        
        // Adicionar produtos pré-carregados para esta categoria
        categoriesMap[category].forEach(p => {
            // Criar elemento do produto (mesma lógica de displayProducts)
            const productElement = createProductElement(p);
            window.preloadedElements[category].products.push(productElement);
        });
    }
    
    // Marcar o carregamento como concluído
    visibleProducts += preloadAmount;
    isLoading = false;
    
    // console.log(`Pré-carregado ${preloadAmount} produtos silenciosamente`);
}


// Adicionar elementos pré-carregados à página
function appendPreloadedElements() {
    if (!window.preloadedElements) return;
    
    const productListElement = document.getElementById('product-list');
    
    // Para cada categoria com elementos pré-carregados
    for (const category in window.preloadedElements) {
        const categoryData = window.preloadedElements[category];
        
        if (!categoryData || !categoryData.products || categoryData.products.length === 0) {
            continue;
        }
        
        // Procurar seção existente ou criar nova
        let categorySection = document.querySelector(`.category-section[data-category="${category}"]`);
        let productContainer;
        
        if (!categorySection) {
            // Usar a seção pré-criada
            categorySection = categoryData.container;
            productListElement.appendChild(categorySection);
            productContainer = categorySection.querySelector('.products');
        } else {
            // Usar o container existente
            productContainer = categorySection.querySelector('.products');
        }
        
        // Adicionar produtos com otimização DOM
        if (productContainer && categoryData.products.length > 0) {
            // Criar um fragmento para adicionar todos os produtos de uma vez
            const fragment = document.createDocumentFragment();
            categoryData.products.forEach(product => {
                fragment.appendChild(product);
            });
            
            // Adicionar o fragmento ao container (operação DOM única)
            productContainer.appendChild(fragment);
        }
    }
    
    // Limpar memória após adicionar à página
    window.preloadedElements = {};
}


// Popular seletor de categorias
function populateCategories() {
    let categories = [...new Set(allProducts.map(p => p.categoria))].sort();
    let categorySelect = document.getElementById("category");
    categorySelect.innerHTML = '<option value="">Todas as Categorias</option>';
    
    categories.forEach(cat => {
        let option = document.createElement("option");
        option.value = cat;
        option.textContent = cat.charAt(0).toUpperCase() + cat.slice(1);
        categorySelect.appendChild(option);
    });
}

// Versão melhorada da função handleImageError
function handleImageError(img, sku) {
    console.warn(`Erro ao carregar imagem para SKU ${sku}. Substituindo por placeholder.`);
    
    // Verificar se a URL já é um placeholder para evitar loop
    if (img.src.includes('placeholder.com')) return;
    
    // Usar uma imagem de placeholder
    img.src = `https://via.placeholder.com/300x300?text=${encodeURIComponent(`Produto ${sku}`)}`;
    
    // Adicionar classe para estilo específico
    img.classList.add('placeholder-img');
}

// Abrir modal de imagem
function openImageModal(imgSrc, sku, name) {
    // Se a imagem estiver vazia, usar placeholder
    if (!imgSrc || imgSrc === '') {
        document.getElementById("modalImg").src = "https://via.placeholder.com/500x500?text=Imagem+Indisponível";
    } else {
        document.getElementById("modalImg").src = imgSrc;
    }
    
    document.getElementById("modalProductInfo").innerHTML = `
        <strong>${sku}</strong><br>
        ${name}
    `;
    
    openModal('imageModal');
}

// Funções para controle de carrinho
function incrementQuantity(sku) {
    const inputElement = document.getElementById(`qty-${sku}`);
    let value = parseInt(inputElement.value || 0);
    inputElement.value = value + 1;
    
    // Se o produto já estiver no carrinho, atualizar a quantidade
    updateCartItemQuantity(sku, value + 1);
}

function decrementQuantity(sku) {
    const inputElement = document.getElementById(`qty-${sku}`);
    let value = parseInt(inputElement.value || 0);
    if (value > 0) {
        inputElement.value = value - 1;
        
        // Atualizar quantidade no carrinho
        updateCartItemQuantity(sku, value - 1);
        
        // Se a quantidade for zero, remover do carrinho
        if (value - 1 === 0) {
            removeFromCart(sku);
        }
    }
}

function toggleCart(sku, name, category) {
    const inCart = cart.some(item => item.sku === sku);
    
    if (inCart) {
        removeFromCart(sku);
    } else {
        // Obter a quantidade atual
        const quantityInput = document.getElementById(`qty-${sku}`);
        const quantity = parseInt(quantityInput.value || 1);
        
        // Se a quantidade for zero, definir como 1
        if (quantity === 0) {
            quantityInput.value = 1;
            addToCart(sku, name, category, 1);
        } else {
            addToCart(sku, name, category, quantity);
        }
    }
}

function addToCart(sku, name, category, quantity = 1) {
    // Verificar se o produto já está no carrinho
    const existingItemIndex = cart.findIndex(item => item.sku === sku);
    
    if (existingItemIndex >= 0) {
        // Atualizar a quantidade se já existir
        cart[existingItemIndex].quantity = quantity;
    } else {
        // Adicionar novo item ao carrinho
        cart.push({
            sku,
            name,
            category,
            quantity
        });
    }
    
    // Atualizar o botão do produto
    updateCartButton(sku, true);
    
    // Atualizar o contador do carrinho
    updateCartCount();
    
    // Salvar o carrinho no localStorage
    saveCart();
}

function removeFromCart(sku) {
    // Filtrar o carrinho para remover o item
    cart = cart.filter(item => item.sku !== sku);
    
    // Atualizar o botão do produto
    updateCartButton(sku, false);
    
    // Zerar o input de quantidade
    const quantityInput = document.getElementById(`qty-${sku}`);
    if (quantityInput) {
        quantityInput.value = 0;
    }
    
    // Atualizar o contador do carrinho
    updateCartCount();
    
    // Salvar o carrinho no localStorage
    saveCart();
    
    // Atualizar a exibição do carrinho se estiver aberto
    if (document.getElementById('cartModal').style.display === 'flex') {
        renderCartItems();
    }
}

function updateCartItemQuantity(sku, quantity) {
    // Encontrar o item no carrinho
    const itemIndex = cart.findIndex(item => item.sku === sku);
    
    if (quantity <= 0) {
        // Se a quantidade for zero ou negativa, remover do carrinho
        if (itemIndex >= 0) {
            removeFromCart(sku);
        }
    } else {
        if (itemIndex >= 0) {
            // Atualizar a quantidade
            cart[itemIndex].quantity = quantity;
            
            // Salvar o carrinho
            saveCart();
            
            // Atualizar a exibição do carrinho se estiver aberto
            if (document.getElementById('cartModal').style.display === 'flex') {
                renderCartItems();
            }
        } else {
            // Se o item não estiver no carrinho mas tiver quantidade > 0,
            // encontrar o produto na lista e adicionar ao carrinho
            const product = allProducts.find(p => p.sku === sku);
            if (product) {
                addToCart(sku, product.marca, product.categoria, quantity);
            }
        }
    }
}

function updateCartButton(sku, inCart) {
    const cartBtn = document.getElementById(`cart-btn-${sku}`);
    
    if (cartBtn) {
        if (inCart) {
            cartBtn.classList.add('in-cart');
            cartBtn.innerHTML = '<i class="fas fa-check"></i>';
        } else {
            cartBtn.classList.remove('in-cart');
            cartBtn.innerHTML = '<i class="fas fa-cart-plus"></i>';
        }
    }
}

function updateCartCount() {
    // Calcular a quantidade total de itens no carrinho
    const totalItems = cart.reduce((sum, item) => sum + item.quantity, 0);
    
    // Atualizar o contador no indicador do carrinho
    document.querySelector('.cart-count').textContent = totalItems;
}

function saveCart() {
    localStorage.setItem('cart', JSON.stringify(cart));
}

function clearCart() {
    // Limpar array do carrinho
    cart = [];
    
    // Atualizar exibição
    renderCartItems();
    
    // Atualizar contador
    updateCartCount();
    
    // Salvar carrinho vazio
    saveCart();
    
    // Redefinir todos os botões e quantidades
    document.querySelectorAll('.add-to-cart').forEach(btn => {
        const sku = btn.id.replace('cart-btn-', '');
        updateCartButton(sku, false);
        
        const quantityInput = document.getElementById(`qty-${sku}`);
        if (quantityInput) {
            quantityInput.value = 0;
        }
    });
}

function openCartModal() {
    renderCartItems();
    openModal('cartModal');
}

function renderCartItems() {
    const cartItemsContainer = document.getElementById('cart-items');
    
    if (cart.length === 0) {
        cartItemsContainer.innerHTML = '<div class="empty-cart-message">Seu carrinho está vazio</div>';
        return;
    }
    
    let html = '';
    
    cart.forEach(item => {
        html += `
            <div class="cart-item" data-sku="${item.sku}">
                <div class="cart-item-info">
                    <div class="cart-item-name">${item.name}</div>
                    <div class="cart-item-sku">Código: ${item.sku}</div>
                </div>
                <div class="cart-item-qty">
                    <button class="qty-btn" onclick="decrementCartItem('${item.sku}')">-</button>
                    <input type="number" class="qty-input" value="${item.quantity}" min="1" max="999" readonly>
                    <button class="qty-btn" onclick="incrementCartItem('${item.sku}')">+</button>
                    <button class="qty-btn" onclick="removeFromCart('${item.sku}')" style="margin-left:5px">
                        <i class="fas fa-trash"></i>
                    </button>
                </div>
            </div>
        `;
    });
    
    cartItemsContainer.innerHTML = html;
}

function incrementCartItem(sku) {
    // Encontrar o item no carrinho
    const item = cart.find(i => i.sku === sku);
    
    if (item) {
        item.quantity += 1;
        
        // Atualizar o input na lista de produtos
        const quantityInput = document.getElementById(`qty-${sku}`);
        if (quantityInput) {
            quantityInput.value = item.quantity;
        }
        
        // Salvar e renderizar
        saveCart();
        renderCartItems();
        updateCartCount();
    }
}

function decrementCartItem(sku) {
    // Encontrar o item no carrinho
    const item = cart.find(i => i.sku === sku);
    
    if (item && item.quantity > 1) {
        item.quantity -= 1;
        
        // Atualizar o input na lista de produtos
        const quantityInput = document.getElementById(`qty-${sku}`);
        if (quantityInput) {
            quantityInput.value = item.quantity;
        }
        
        // Salvar e renderizar
        saveCart();
        renderCartItems();
        updateCartCount();
    } else if (item && item.quantity <= 1) {
        // Se a quantidade for 1, remover do carrinho
        removeFromCart(sku);
    }
}

function sendToWhatsApp() {
    if (cart.length === 0) {
        alert("Seu carrinho está vazio.");
        return;
    }
    
    // Formatação do texto para o WhatsApp
    let message = "Olá! Gostaria de fazer um pedido:\n\n";
    
    cart.forEach(item => {
        message += `cod ${item.sku} ${item.quantity}und ${item.name}\n`;
        message += "-------------\n";
    });
    
    // Codificar a mensagem para URL
    const encodedMessage = encodeURIComponent(message);
    
    // Abrir o WhatsApp com a mensagem preenchida
    window.open(`https://wa.me/?text=${encodedMessage}`, '_blank');
}

// Funções para seleção de produtos (modo vendedor)
function toggleProductSelection(sku, name, category, imgSrc) {
    const isSelected = selectedProducts.some(item => item.sku === sku);
    
    if (isSelected) {
        // Remover da seleção
        selectedProducts = selectedProducts.filter(item => item.sku !== sku);
        
        // Atualizar a UI para refletir a deseleção
        const productElement = document.querySelector(`.product[data-sku="${sku}"]`);
        if (productElement) {
            productElement.classList.remove('selected');
            const selectIcon = productElement.querySelector('.product-select');
            if (selectIcon) {
                selectIcon.innerHTML = '';
            }
        }
    } else {
        // IMPORTANTE: Sempre buscar a URL da imagem diretamente do objeto allProducts (dados do CSV)
        const originalProduct = allProducts.find(p => p.sku === sku);
        if (!originalProduct) {
            console.error(`Produto com SKU ${sku} não encontrado nos dados originais do CSV`);
            return;
        }
        
        // Usar APENAS a URL da imagem do CSV
        const imageUrl = originalProduct.img;
        console.log(`Selecionando produto ${sku} com imagem do CSV: ${imageUrl}`);
        
        // Adicionar à seleção
        selectedProducts.push({
            sku,
            name,
            category,
            imgSrc: imageUrl, // GARANTIR que estamos usando a imagem do CSV
            price: '' // Iniciar com preço vazio
        });
        
        // Atualizar a UI para refletir a seleção
        const productElement = document.querySelector(`.product[data-sku="${sku}"]`);
        if (productElement) {
            productElement.classList.add('selected');
            const selectIcon = productElement.querySelector('.product-select');
            if (selectIcon) {
                selectIcon.innerHTML = '<i class="fas fa-check"></i>';
            }
            
            // Adicionar campo de preço
            const productInfo = productElement.querySelector('.product-info');
            if (productInfo && !productInfo.querySelector('.price-input-group')) {
                const priceInput = document.createElement('div');
                priceInput.className = 'price-input-group';
                priceInput.innerHTML = `
                    <span class="currency-symbol">R$</span>
                    <input type="text" class="product-price-input" 
                           placeholder="Insira o preço" 
                           value=""
                           onchange="updateProductPrice('${sku}', this.value)">
                `;
                productInfo.insertBefore(priceInput, productInfo.querySelector('.product-controls'));
            }
        }
    }
    
    // Salvar a seleção atual
    localStorage.setItem('selectedProducts', JSON.stringify(selectedProducts));
    
    // Atualizar contador
    updateSelectionCount();
}

// Atualizar preço de um produto selecionado
function updateProductPrice(sku, price) {
    const selectedIndex = selectedProducts.findIndex(item => item.sku === sku);
    
    if (selectedIndex >= 0) {
        selectedProducts[selectedIndex].price = price;
        localStorage.setItem('selectedProducts', JSON.stringify(selectedProducts));
    }
}

function toggleCategorySelection(category) {
    // Recuperar produtos nesta categoria do conjunto atual de dados
    const productsInCategory = productData.filter(p => p.categoria === category);
    
    // Verificação de validação de entrada
    if (!productsInCategory.length) {
        console.warn(`Nenhum produto encontrado na categoria: ${category}`);
        return;
    }
    
    // Verificar se todos os produtos da categoria já estão selecionados
    const allSelected = productsInCategory.every(p => 
        selectedProducts.some(item => item.sku === p.sku)
    );
    
    if (allSelected) {
        // Caminho de execução: Desmarcar todos os produtos
        productsInCategory.forEach(p => {
            const isSelected = selectedProducts.some(item => item.sku === p.sku);
            if (isSelected) {
                toggleProductSelection(p.sku, p.marca, p.categoria, p.img);
            }
        });
    } else {
        // Caminho de execução: Selecionar todos os produtos não selecionados
        productsInCategory.forEach(p => {
            const isSelected = selectedProducts.some(item => item.sku === p.sku);
            if (!isSelected) {
                toggleProductSelection(p.sku, p.marca, p.categoria, p.img);
            }
        });
    }
}

function updateSelectionCount() {
    const count = selectedProducts.length;
    document.querySelector('.selection-count').textContent = 
        count === 1 ? '1 produto selecionado' : `${count} produtos selecionados`;
    
    // Refletir o nome da coleção no campo
    const collectionName = document.getElementById('collection-name').value;
    if (collectionName) {
        document.getElementById('pdf-collection-name').value = collectionName;
    }
}

// Abrir modal para salvar coleção
function openSaveCollectionModal() {
    if (selectedProducts.length === 0) {
        showNotification('Selecione pelo menos um produto para criar uma coleção', 'error');
        return;
    }
    
    // Preencher o nome da coleção a partir do campo na interface
    const currentName = document.getElementById('collection-name').value;
    document.getElementById('save-collection-name').value = currentName;
    
    openModal('saveCollectionModal');
}

// Salvar coleção atual
function saveCollection() {
    const name = document.getElementById('save-collection-name').value.trim();
    const description = document.getElementById('collection-description').value.trim();
    const keepSelected = document.getElementById('save-as-default').checked;
    const includePrices = document.getElementById('include-prices').checked;
    
    if (!name) {
        showNotification('Informe um nome para a coleção', 'error');
        return;
    }
    
    if (selectedProducts.length === 0) {
        showNotification('Selecione pelo menos um produto para criar uma coleção', 'error');
        return;
    }
    
    // Verificar se já existe uma coleção com este nome
    const existingIndex = collections.findIndex(c => c.name.toLowerCase() === name.toLowerCase());
    
    // Criar uma cópia dos produtos selecionados
    let selectedProductsCopy = selectedProducts.map(p => ({...p}));
    
    // Remover preços se a opção não estiver marcada
    if (!includePrices) {
        selectedProductsCopy = selectedProductsCopy.map(p => {
            const newP = {...p};
            newP.price = '';
            return newP;
        });
    }
    
    if (existingIndex >= 0) {
        // Atualizar coleção existente
        collections[existingIndex] = {
            ...collections[existingIndex],
            name,
            description,
            products: selectedProductsCopy,
            updatedAt: new Date().toISOString()
        };
        
        showNotification(`Coleção "${name}" atualizada com sucesso!`, 'success');
    } else {
        // Criar nova coleção
        collections.push({
            id: Date.now().toString(),
            name,
            description,
            products: selectedProductsCopy,
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString()
        });
        
        showNotification(`Coleção "${name}" criada com sucesso!`, 'success');
    }
    
    // Salvar no localStorage
    localStorage.setItem('collections', JSON.stringify(collections));
    
    // Atualizar o número de coleções
    updateCollectionCount();
    
    // Atualizar o input de nome da coleção na interface principal
    document.getElementById('collection-name').value = name;
    
    // Limpar a seleção se o usuário desejar
    if (!keepSelected) {
        clearSelection();
    }
    
    // Fechar o modal
    closeModal('saveCollectionModal');
}

// Limpar seleção atual
function clearSelection() {
    selectedProducts = [];
    localStorage.setItem('selectedProducts', JSON.stringify(selectedProducts));
    
    // Atualizar UI
    document.querySelectorAll('.product.selected').forEach(product => {
        product.classList.remove('selected');
        const selectIcon = product.querySelector('.product-select');
        if (selectIcon) {
            selectIcon.innerHTML = '';
        }
        
        // Remover campo de preço
        const priceInput = product.querySelector('.price-input-group');
        if (priceInput) {
            priceInput.remove();
        }
    });
    
    updateSelectionCount();
    document.getElementById('collection-name').value = '';
}

// Abrir modal para gerenciar coleções
function openManageCollectionsModal() {
    const collectionsContainer = document.getElementById('collections-container');
    
    if (collections.length === 0) {
        collectionsContainer.innerHTML = `
            <div class="empty-collections">
                <i class="fas fa-folder-open"></i>
                <p>Você ainda não tem coleções salvas</p>
                <p>Crie sua primeira coleção selecionando produtos e clicando em "Salvar Coleção"</p>
            </div>
        `;
    } else {
        let html = '<ul class="collections-list">';
        
        collections.forEach(collection => {
            const date = new Date(collection.updatedAt).toLocaleDateString();
            const count = collection.products.length;
            
            html += `
                <li class="collection-item" data-id="${collection.id}">
                    <div class="collection-item-info">
                        <div class="collection-item-name">${collection.name}</div>
                        <div class="collection-item-meta">
                            <span>${count} ${count === 1 ? 'produto' : 'produtos'}</span>
                            <span>Atualizado em: ${date}</span>
                        </div>
                    </div>
                    <div class="collection-item-actions">
                        <button class="collection-action-btn view" onclick="viewCollectionProducts('${collection.id}')">
                            <i class="fas fa-eye"></i> Ver produtos
                        </button>
                        <button class="collection-action-btn edit" onclick="loadCollection('${collection.id}')">
                            <i class="fas fa-edit"></i> Editar
                        </button>
                        <button class="collection-action-btn pdf" onclick="openPdfModalForCollection('${collection.id}')">
                            <i class="fas fa-file-pdf"></i> PDF
                        </button>
                        <button class="collection-action-btn delete" onclick="deleteCollection('${collection.id}')">
                            <i class="fas fa-trash"></i> Excluir
                        </button>
                    </div>
                </li>
            `;
        });
        
        html += '</ul>';
        collectionsContainer.innerHTML = html;
    }
    
    openModal('manageCollectionsModal');
}

// Atualizar contador de coleções
function updateCollectionCount() {
    document.querySelector('.collection-count').textContent = collections.length;
}

// Carregar uma coleção existente
function loadCollection(collectionId) {
    const collection = collections.find(c => c.id === collectionId);
    
    if (!collection) {
        showNotification('Coleção não encontrada', 'error');
        return;
    }
    
    // Carregar produtos da coleção
    selectedProducts = JSON.parse(JSON.stringify(collection.products)); // Deep copy
    localStorage.setItem('selectedProducts', JSON.stringify(selectedProducts));
    
    // Atualizar nome da coleção
    document.getElementById('collection-name').value = collection.name;
    
    // Reexibir produtos para atualizar a seleção
    displayProducts();
    
    // Atualizar contador
    updateSelectionCount();
    
    // Fechar o modal
    closeModal('manageCollectionsModal');
    
    // Alternar para modo vendedor se ainda não estiver nele
    if (!inVendorMode) {
        inVendorMode = true;
        localStorage.setItem('vendorMode', true);
        applyCurrentMode();
        displayProducts(); // Reexibir produtos no novo modo
    }
    
    showNotification(`Coleção "${collection.name}" carregada com sucesso!`, 'success');
}

// NOVA IMPLEMENTAÇÃO 1: Excluir coleção sem deixar vestígios
function deleteCollection(collectionId) {
    if (confirm("Tem certeza que deseja excluir esta coleção?")) {
        const collectionIndex = collections.findIndex(c => c.id === collectionId);
        
        if (collectionIndex >= 0) {
            const collectionName = collections[collectionIndex].name;
            const deletedCollection = collections[collectionIndex];
            
            // Verificar se a coleção que está sendo excluída é a que está selecionada atualmente
            let isCurrentCollection = false;
            
            // Comparar a coleção atual com a que está sendo excluída
            // (verificando se os produtos selecionados correspondem aos da coleção)
            if (selectedProducts.length > 0 && 
                document.getElementById('collection-name').value === deletedCollection.name) {
                isCurrentCollection = true;
            }
            
            // Remover a coleção do array
            collections.splice(collectionIndex, 1);
            
            // Salvar no localStorage
            localStorage.setItem('collections', JSON.stringify(collections));
            
            // Se for a coleção atual, limpar a seleção
            if (isCurrentCollection) {
                clearSelection();
                document.getElementById('collection-name').value = '';
            }
            
            // Atualizar o número de coleções
            updateCollectionCount();
            
            // Atualizar a exibição
            openManageCollectionsModal();
            
            showNotification(`Coleção "${collectionName}" excluída com sucesso!`, 'success');
        }
    }
}

// NOVA IMPLEMENTAÇÃO 2: Funções para visualizar apenas os produtos de uma coleção
function viewCollectionProducts(collectionId) {
    // Buscar a coleção
    const collection = collections.find(c => c.id === collectionId);
    
    if (!collection) {
        showNotification('Coleção não encontrada', 'error');
        return;
    }
    
    // Definir o filtro ativo
    activeCollectionFilter = {
        id: collectionId,
        name: collection.name,
        skus: collection.products.map(p => p.sku)
    };
    
    // Fechar o modal de gerenciamento
    closeModal('manageCollectionsModal');
    
    // Mostrar notificação
    showNotification(`Exibindo produtos da coleção "${collection.name}"`, 'success');
    
    // Adicionar banner de filtro ativo
    addCollectionFilterBanner(collection.name);
    
    // Aplicar o filtro e exibir os produtos
    displayProducts();
}

function addCollectionFilterBanner(collectionName) {
    // Remover banner existente se houver
    removeCollectionFilterBanner();
    
    // Criar o banner
    const banner = document.createElement('div');
    banner.id = 'collection-filter-banner';
    banner.style.backgroundColor = 'rgba(230, 126, 34, 0.1)';
    banner.style.border = '1px solid var(--accent-color)';
    banner.style.borderRadius = '5px';
    banner.style.padding = '10px 15px';
    banner.style.marginBottom = '15px';
    banner.style.display = 'flex';
    banner.style.justifyContent = 'space-between';
    banner.style.alignItems = 'center';
    
    banner.innerHTML = `
        <div>
            <i class="fas fa-filter" style="color: var(--accent-color); margin-right: 8px;"></i>
            <span>Exibindo produtos da coleção: <strong>${collectionName}</strong></span>
        </div>
        <button onclick="clearCollectionFilter()" style="background: var(--accent-color); color: white; border: none; border-radius: 4px; padding: 5px 10px; cursor: pointer;">
            <i class="fas fa-times"></i> Remover filtro
        </button>
    `;
    
    // Inserir o banner antes dos filtros
    const filtersElement = document.querySelector('.filters');
    filtersElement.parentNode.insertBefore(banner, filtersElement);
}

function removeCollectionFilterBanner() {
    const banner = document.getElementById('collection-filter-banner');
    if (banner) {
        banner.parentNode.removeChild(banner);
    }
}

function clearCollectionFilter() {
    activeCollectionFilter = null;
    removeCollectionFilterBanner();
    
    // Reexibir todos os produtos
    displayProducts();
    
    showNotification('Filtro de coleção removido', 'success');
}

// Abrir modal de PDF para uma coleção específica
function openPdfModalForCollection(collectionId) {
    const collection = collections.find(c => c.id === collectionId);
    
    if (!collection) {
        showNotification('Coleção não encontrada', 'error');
        return;
    }
    
    // Carregar produtos da coleção
    selectedProducts = JSON.parse(JSON.stringify(collection.products)); // Deep copy
    localStorage.setItem('selectedProducts', JSON.stringify(selectedProducts));
    
    // Atualizar nome da coleção para o PDF
    document.getElementById('pdf-collection-name').value = collection.name;
    
    // Fechar o modal de gerenciamento
    closeModal('manageCollectionsModal');
    
    // Abrir o modal de PDF
    openPdfModal();
}

// Abrir modal para gerar PDF
function openPdfModal() {
    if (selectedProducts.length === 0) {
        showNotification('Selecione pelo menos um produto para gerar o PDF', 'error');
        return;
    }
    
    // Preencher o título do PDF a partir do nome da coleção
    const currentName = document.getElementById('collection-name').value;
    if (currentName && !document.getElementById('pdf-collection-name').value) {
        document.getElementById('pdf-collection-name').value = currentName;
    }
    
    // Reset PDF progress bar
    document.getElementById('pdf-progress-container').style.display = 'none';
    document.getElementById('pdf-progress-fill').style.width = '0%';
    document.getElementById('pdf-progress-text').textContent = 'Carregando imagens: 0%';
    
    // Habilitar o botão de gerar PDF
    document.getElementById('generate-pdf-btn').disabled = false;
    
    openModal('pdfModal');
}

// Função para buscar produto na API da Ameripan
async function fetchProductImageFromAPI(sku) {
    try {
        // URL da API (substitua pela URL correta)
        const apiUrl = `https://www.ameripan.com.br/buscar?q=${sku}`;
        
        // Buscar dados da página
        const response = await fetch(apiUrl, {
            method: 'GET',
            mode: 'cors',
            cache: 'no-cache',
            credentials: 'same-origin',
            redirect: 'follow',
            referrerPolicy: 'no-referrer'
        });
        
        if (!response.ok) {
            throw new Error(`Erro ao buscar: ${response.status}`);
        }
        
        const html = await response.text();
        
        // Analisar HTML para encontrar a imagem do produto
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');
        
        // Procurar pelo SKU na página
        const productItems = doc.querySelectorAll('.listagem-item');
        let imageUrl = null;
        
        for (const item of productItems) {
            const skuElement = item.querySelector('.produto-sku.hide');
            
            if (skuElement && skuElement.textContent.trim() === sku) {
                // Encontrou o produto, obter URL da imagem
                const imageElement = item.querySelector('.imagem-produto img');
                if (imageElement && imageElement.src) {
                    imageUrl = imageElement.src;
                    break;
                }
            }
        }
        
        return imageUrl;
    } catch (error) {
        console.error(`Erro ao buscar imagem para SKU ${sku}:`, error);
        return null;
    }
}

// Função para capturar a imagem diretamente da interface do usuário (backup)
function captureImageFromDOM(sku) {
    try {
        const imgElement = document.querySelector(`.product[data-sku="${sku}"] img`);
        
        if (!imgElement || !imgElement.complete || imgElement.naturalWidth === 0) {
            console.warn(`Elemento de imagem para SKU ${sku} não encontrado ou não carregado no DOM`);
            return null;
        }
        
        const canvas = document.createElement('canvas');
        canvas.width = imgElement.naturalWidth || 300;
        canvas.height = imgElement.naturalHeight || 300;
        
        const ctx = canvas.getContext('2d');
        ctx.drawImage(imgElement, 0, 0, canvas.width, canvas.height);
        
        try {
            const dataURL = canvas.toDataURL('image/jpeg', 0.95);
            console.log(`Imagem para SKU ${sku} capturada do DOM com sucesso`);
            return dataURL;
        } catch (e) {
            console.error(`Erro ao converter canvas para dataURL (SKU ${sku}):`, e);
            return null;
        }
    } catch (error) {
        console.error(`Erro ao capturar imagem do DOM para SKU ${sku}:`, error);
        return null;
    }
}

// Função melhorada para pré-carregar imagens e convertê-las para base64
// Improved image loading function with multiple fallback strategies
async function preloadImageAsBase64(url, sku) {
    return new Promise((resolve, reject) => {
        // If URL is empty or invalid, resolve with null
        if (!url || typeof url !== 'string' || url.trim() === '') {
            console.warn(`Empty or invalid URL for SKU ${sku}`);
            resolve(null);
            return;
        }
        
        // Check global cache using SKU-based key first (most reliable)
        const skuCacheKey = `img_${sku}`;
        if (globalImageCache.has(skuCacheKey)) {
            console.log(`Image found in SKU cache for ${sku}`);
            resolve(globalImageCache.get(skuCacheKey));
            return;
        }
        
        // Also check URL-based cache
        if (globalImageCache.has(url)) {
            console.log(`Image found in URL cache: ${url}`);
            resolve(globalImageCache.get(url));
            return;
        }
        
        console.log(`Attempting to load image for SKU ${sku}: ${url}`);
        
        // Create image element with explicit dimensions
        const img = new Image();
        img.crossOrigin = 'Anonymous'; // For CORS
        
        // Success handler with additional error trapping
        img.onload = function() {
            try {
                // Check if image has dimensions
                if (img.width === 0 || img.height === 0) {
                    console.warn(`Image loaded but has zero dimensions: ${url}`);
                    resolve(null);
                    return;
                }
                
                // Limit image dimensions for canvas (prevent "canvas too large" errors)
                const maxDim = 1500;
                let finalWidth = img.width;
                let finalHeight = img.height;
                
                if (finalWidth > maxDim || finalHeight > maxDim) {
                    const ratio = Math.min(maxDim / finalWidth, maxDim / finalHeight);
                    finalWidth = Math.floor(finalWidth * ratio);
                    finalHeight = Math.floor(finalHeight * ratio);
                    console.log(`Resizing large image for SKU ${sku} to ${finalWidth}x${finalHeight}`);
                }
                
                // Create canvas with appropriate dimensions
                const canvas = document.createElement('canvas');
                canvas.width = finalWidth;
                canvas.height = finalHeight;
                
                // Draw image to canvas with resizing if needed
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0, finalWidth, finalHeight);
                
                // Try higher compression for large images
                let quality = 0.8;
                if (finalWidth * finalHeight > 500000) {
                    quality = 0.6; // Higher compression for very large images
                }
                
                // Convert to base64 with appropriate quality
                let dataURL;
                try {
                    dataURL = canvas.toDataURL('image/jpeg', quality);
                } catch (canvasError) {
                    console.error(`Canvas conversion error for SKU ${sku}:`, canvasError);
                    
                    // Try with smaller dimensions as fallback
                    try {
                        canvas.width = Math.min(500, finalWidth);
                        canvas.height = Math.min(500, finalHeight);
                        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                        dataURL = canvas.toDataURL('image/jpeg', 0.5);
                    } catch (fallbackError) {
                        console.error(`Fallback canvas conversion failed for SKU ${sku}:`, fallbackError);
                        resolve(null);
                        return;
                    }
                }
                
                // Verify dataURL is valid
                if (!dataURL || dataURL === 'data:,' || dataURL.length < 100) {
                    console.warn(`Invalid dataURL generated for SKU ${sku}`);
                    resolve(null);
                    return;
                }
                
                // Add to both caching mechanisms
                globalImageCache.set(skuCacheKey, dataURL);
                globalImageCache.set(url, dataURL);
                
                console.log(`Successfully converted image for SKU ${sku}`);
                
                // Save cache to localStorage (with error handling)
                try {
                    const cacheObject = Object.fromEntries(globalImageCache);
                    localStorage.setItem('imageCache', JSON.stringify(cacheObject));
                } catch (storageError) {
                    console.warn("localStorage error (possibly quota exceeded):", storageError);
                    // Try to save just this image
                    try {
                        const singleCache = {};
                        singleCache[skuCacheKey] = dataURL;
                        localStorage.setItem(`imgCache_${sku}`, JSON.stringify(singleCache));
                    } catch (e) {
                        console.warn("Single image cache failed too");
                    }
                }
                
                resolve(dataURL);
            } catch (err) {
                console.error(`Error converting image for SKU ${sku}:`, err);
                resolve(null);
            }
        };
        
        // Error handler
        img.onerror = function() {
            console.warn(`Failed to load image for SKU ${sku}: ${url}`);
            
            // Try alternate URL format - attempt to correct common issues
            tryAlternateUrl(url, sku).then(alternateDataUrl => {
                if (alternateDataUrl) {
                    console.log(`Successfully loaded alternate URL for SKU ${sku}`);
                    resolve(alternateDataUrl);
                } else {
                    resolve(null);
                }
            });
        };
        
        // Set source and start loading with cache-busting query param
        img.src = url + (url.includes('?') ? '&' : '?') + 'nocache=' + new Date().getTime();
        
        // Increased timeout to 10 seconds for larger images
        setTimeout(() => {
            if (!img.complete) {
                console.warn(`Timeout (10s) loading image for SKU ${sku}: ${url}`);
                img.src = ''; // Cancel the request
                resolve(null);
            }
        }, 10000);
    });
}

// Function to try alternate URL formats when the primary URL fails
async function tryAlternateUrl(originalUrl, sku) {
    // Common image URL patterns and fixes
    const attempts = [
        // Try without cache busting parameters
        url => url.split('?')[0],
        
        // Try with https instead of http
        url => url.replace('http://', 'https://'),
        
        // Try without www if present, or with www if not
        url => url.includes('www.') ? url.replace('www.', '') : url.replace('://', '://www.'),
        
        // Try with .jpg if no extension exists
        url => {
            const baseUrl = url.split('?')[0];
            if (!baseUrl.match(/\.(jpg|jpeg|png|gif)$/i)) {
                return baseUrl + '.jpg';
            }
            return null;
        },
        
        // Try with .png if no extension exists
        url => {
            const baseUrl = url.split('?')[0];
            if (!baseUrl.match(/\.(jpg|jpeg|png|gif)$/i)) {
                return baseUrl + '.png';
            }
            return null;
        }
    ];
    
    // Check if we can find product info in allProducts
    const product = allProducts.find(p => p.sku === sku);
    if (product && product.img && product.img !== originalUrl) {
        // Try the original URL from the product data first
        console.log(`Trying original product URL for SKU ${sku}: ${product.img}`);
        const result = await attemptImageLoad(product.img);
        if (result) return result;
    }
    
    // Try each URL transformation
    for (const transform of attempts) {
        const altUrl = transform(originalUrl);
        
        // Skip null or same URL
        if (!altUrl || altUrl === originalUrl) continue;
        
        console.log(`Trying alternate URL for SKU ${sku}: ${altUrl}`);
        const result = await attemptImageLoad(altUrl);
        if (result) return result;
    }
    
    // All attempts failed
    return null;
}

// Helper function to attempt loading an image
function attemptImageLoad(url) {
    return new Promise(resolve => {
        const img = new Image();
        img.crossOrigin = 'Anonymous';
        
        img.onload = function() {
            try {
                // Only process if image has dimensions
                if (img.width === 0 || img.height === 0) {
                    resolve(null);
                    return;
                }
                
                // Create canvas and convert to base64
                const canvas = document.createElement('canvas');
                const maxDim = 800; // Limit size
                
                let w = img.width;
                let h = img.height;
                if (w > maxDim || h > maxDim) {
                    const ratio = Math.min(maxDim/w, maxDim/h);
                    w = Math.floor(w * ratio);
                    h = Math.floor(h * ratio);
                }
                
                canvas.width = w;
                canvas.height = h;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0, w, h);
                
                const dataURL = canvas.toDataURL('image/jpeg', 0.7);
                resolve(dataURL);
            } catch (err) {
                console.error(`Error in attemptImageLoad for ${url}:`, err);
                resolve(null);
            }
        };
        
        img.onerror = function() {
            resolve(null);
        };
        
        // Add cache-busting
        img.src = url + (url.includes('?') ? '&' : '?') + 'cb=' + Date.now();
        
        // Safety timeout
        setTimeout(() => {
            if (!img.complete) {
                img.src = '';
                resolve(null);
            }
        }, 5000);
    });
}

// Load and recover all available cache when page loads
function loadAllImageCaches() {
    try {
        // Try main cache first
        const mainCache = localStorage.getItem('imageCache');
        if (mainCache) {
            try {
                const cacheData = JSON.parse(mainCache);
                globalImageCache = new Map(Object.entries(cacheData));
                console.log(`Loaded ${globalImageCache.size} images from main cache`);
            } catch (e) {
                console.warn("Failed to parse main image cache:", e);
                globalImageCache = new Map();
            }
        }
        
        // Look for individual cached images
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && key.startsWith('imgCache_')) {
                try {
                    const sku = key.replace('imgCache_', '');
                    const cacheData = JSON.parse(localStorage.getItem(key));
                    
                    // Add to global cache
                    Object.entries(cacheData).forEach(([cacheKey, dataUrl]) => {
                        globalImageCache.set(cacheKey, dataUrl);
                    });
                    
                    console.log(`Recovered cache for SKU ${sku}`);
                } catch (e) {
                    console.warn(`Failed to load individual cache ${key}:`, e);
                }
            }
        }
    } catch (error) {
        console.error("Error loading image caches:", error);
        globalImageCache = new Map();
    }
}

// Initialize cache on page load
document.addEventListener('DOMContentLoaded', () => {
    // Other initialization code...
    
    // Load all available image caches
    loadAllImageCaches();
});

// Modified preloadAllImages function for more reliable loading
async function preloadAllImages(products) {
    const imageCache = new Map();
    const sessionId = Date.now().toString();
    
    // Reset state
    pdfGenerationState = {
        inProgress: true,
        processedItems: 0,
        totalItems: products.length,
        sessionId,
        imageCache,
        retryCount: {}
    };
    
    // Show progress bar
    const progressContainer = document.getElementById('pdf-progress-container');
    progressContainer.style.display = 'block';
    
    // Clear progress
    document.getElementById('pdf-progress-fill').style.width = '0%';
    document.getElementById('pdf-progress-text').textContent = 'Carregando imagens: 0%';
    
    // Load images in batches to avoid overwhelming the browser
    // Process 3 images at a time with a small delay between batches
    const batchSize = 3;
    
    for (let i = 0; i < products.length; i += batchSize) {
        const batch = products.slice(i, i + batchSize);
        const batchPromises = batch.map(async (product) => {
            try {
                // Get original product data from allProducts
                const originalProduct = allProducts.find(p => p.sku === product.sku);
                
                if (!originalProduct || !originalProduct.img) {
                    console.warn(`No image URL found in CSV for SKU ${product.sku}`);
                    updateProgressBar(i + batch.indexOf(product), products.length);
                    return;
                }
                
                const imageUrl = originalProduct.img;
                console.log(`Processing image for SKU ${product.sku}: ${imageUrl}`);
                
                // Try to load the image
                const dataUrl = await preloadImageAsBase64(imageUrl, product.sku);
                
                if (dataUrl) {
                    // Store in cache
                    imageCache.set(product.sku, dataUrl);
                    product.imgSrc = imageUrl; // Keep consistent URL reference
                    console.log(`Successfully cached image for SKU ${product.sku}`);
                } else {
                    console.warn(`Failed to load image for SKU ${product.sku}`);
                }
                
                updateProgressBar(i + batch.indexOf(product), products.length);
            } catch (error) {
                console.error(`Error processing image for ${product.sku}:`, error);
                updateProgressBar(i + batch.indexOf(product), products.length);
            }
        });
        
        // Wait for the current batch to complete
        await Promise.all(batchPromises);
        
        // Add a small delay between batches to allow UI updates
        if (i + batchSize < products.length) {
            await new Promise(resolve => setTimeout(resolve, 50));
        }
    }
    
    // Mark process as complete
    pdfGenerationState.inProgress = false;
    
    // Final progress update
    document.getElementById('pdf-progress-text').textContent = 
        `${imageCache.size} de ${products.length} imagens carregadas (${Math.round((imageCache.size/products.length)*100)}%)`;
    
    return imageCache;
    
    // Helper to update progress bar
    function updateProgressBar(current, total) {
        const percentage = Math.round(((current + 1) / total) * 100);
        
        const progressFill = document.getElementById('pdf-progress-fill');
        const progressText = document.getElementById('pdf-progress-text');
        
        progressFill.style.width = `${percentage}%`;
        progressText.textContent = `Carregando imagens: ${percentage}%`;
    }
}

// Update the toggleProductSelection function to always store the original CSV image URL
function toggleProductSelection(sku, name, category, imgSrc) {
    const isSelected = selectedProducts.some(item => item.sku === sku);
    
    if (isSelected) {
        // Remove from selection
        selectedProducts = selectedProducts.filter(item => item.sku !== sku);
        
        // Update UI to reflect deselection
        const productElement = document.querySelector(`.product[data-sku="${sku}"]`);
        if (productElement) {
            productElement.classList.remove('selected');
            const selectIcon = productElement.querySelector('.product-select');
            if (selectIcon) {
                selectIcon.innerHTML = '';
            }
        }
    } else {
        // Get the EXACT image URL from the original product data
        const originalProduct = allProducts.find(p => p.sku === sku);
        if (!originalProduct) {
            console.error(`Product with SKU ${sku} not found in original CSV data`);
            return;
        }
        
        // Add to selection with the original URL
        selectedProducts.push({
            sku,
            name,
            category,
            imgSrc: originalProduct.img, // Always use original CSV image URL
            price: '' // Start with empty price
        });
        
        // Update UI to reflect selection
        const productElement = document.querySelector(`.product[data-sku="${sku}"]`);
        if (productElement) {
            productElement.classList.add('selected');
            const selectIcon = productElement.querySelector('.product-select');
            if (selectIcon) {
                selectIcon.innerHTML = '<i class="fas fa-check"></i>';
            }
            
            // Add price field
            const productInfo = productElement.querySelector('.product-info');
            if (productInfo && !productInfo.querySelector('.price-input-group')) {
                const priceInput = document.createElement('div');
                priceInput.className = 'price-input-group';
                priceInput.innerHTML = `
                    <span class="currency-symbol">R$</span>
                    <input type="text" class="product-price-input" 
                           placeholder="Insira o preço" 
                           value=""
                           onchange="updateProductPrice('${sku}', this.value)">
                `;
                productInfo.insertBefore(priceInput, productInfo.querySelector('.product-controls'));
            }
        }
    }
    
    // Save the current selection
    localStorage.setItem('selectedProducts', JSON.stringify(selectedProducts));
    
    // Update counter
    updateSelectionCount();
}


// Função melhorada para tentar múltiplas URLs de imagem
async function tryMultipleImageUrls(sku, baseUrls, retryCount = 0) {
    // Adicionar mais URLs alternativas (inclusive com diferentes extensões)
    const extendedBaseUrls = [
        ...baseUrls,
        'https://www.ameripan.com.br/media/catalog/product/',
        'https://ameripan.com.br/img/produtos/',
        'https://ameripan.vteximg.com.br/arquivos/ids/',
        'https://www.americafoods.com.br/media/catalog/product/',
        'https://www.haraldsabor.com.br/img/produtos/',
        'https://www.sicao.com.br/media/catalog/product/'
    ];
    
    // Tentar diferentes extensões de arquivo
    const extensions = ['.jpg', '.jpeg', '.png', '.webp'];
    
    // Para cada URL base, tentar cada extensão
    for (const baseUrl of extendedBaseUrls) {
        for (const ext of extensions) {
            try {
                // Construir URL completa
                const url = `${baseUrl}${sku}${ext}`;
                
                // Verificar se a URL é válida
                try {
                    const response = await fetch(url, { 
                        method: 'HEAD',
                        mode: 'no-cors', // Tentar contornar limitações de CORS
                        cache: 'force-cache' // Usar cache do navegador quando possível
                    });
                    
                    if (response.ok || response.status === 0) { // Status 0 pode ocorrer com no-cors
                        console.log(`URL de imagem encontrada para SKU ${sku}: ${url}`);
                        return url;
                    }
                } catch (err) {
                    // Continuar tentando outras combinações
                }
            } catch (error) {
                // Ignorar erro e continuar tentando
            }
        }
    }
    
    // Tentar obter da API apenas se outras tentativas falharem
    try {
        const apiImageUrl = await fetchProductImageFromAPI(sku);
        if (apiImageUrl) {
            return apiImageUrl;
        }
    } catch (error) {
        console.warn(`Erro ao buscar imagem da API para SKU ${sku}:`, error);
    }
    
    // Se todas as tentativas falharem, tentar uma busca no Google Images como último recurso
    if (retryCount === 0) {
        try {
            // Construir uma URL de produto típica da ameripan
            const fallbackUrl = `https://www.ameripan.com.br/produto/${sku}`;
            console.log(`Tentando URL de fallback para SKU ${sku}: ${fallbackUrl}`);
            return fallbackUrl;
        } catch (error) {
            console.error(`Erro ao criar URL de fallback para SKU ${sku}:`, error);
        }
    }
    
    console.warn(`Nenhuma URL de imagem encontrada para SKU ${sku} após todas as tentativas`);
    return null;
}

// Função melhorada para pré-carregar todas as imagens
async function preloadAllImages(products) {
    const imageCache = new Map();
    const imageTasks = [];
    const sessionId = Date.now().toString(); // ID único para esta sessão de carregamento
    
    // Configurar estado do processo
    pdfGenerationState = {
        inProgress: true,
        processedItems: 0,
        totalItems: products.length,
        sessionId,
        imageCache,
        retryCount: {}
    };
    
    // Mostrar barra de progresso
    const progressContainer = document.getElementById('pdf-progress-container');
    progressContainer.style.display = 'block';
    
    // Baseado nas bases de URLs alternativas conhecidas
    const baseUrls = [
        'https://www.ameripan.com.br/media/catalog/product/',
        'https://ameripan.com.br/img/produtos/',
        'https://ameripan.vteximg.com.br/arquivos/ids/',
        'https://www.americafoods.com.br/media/catalog/product/'
    ];
    
    // Para cada produto, tente carregar sua imagem
    for (const product of products) {
        const task = (async (prod) => {
            try {
                // Controlar tentativas por SKU
                if (!pdfGenerationState.retryCount[prod.sku]) {
                    pdfGenerationState.retryCount[prod.sku] = 0;
                }
                
                // Aumentar limite de tentativas de 3 para 5
                if (pdfGenerationState.retryCount[prod.sku] >= 5) {
                    console.warn(`Máximo de tentativas atingido para SKU ${prod.sku}`);
                    updateProgressBar();
                    return;
                }
                
                pdfGenerationState.retryCount[prod.sku]++;
                
                // Verificar se já existe no cache global
                const cacheKey = `img_${prod.sku}`;
                if (globalImageCache.has(cacheKey)) {
                    imageCache.set(prod.sku, globalImageCache.get(cacheKey));
                    console.log(`Imagem para SKU ${prod.sku} recuperada do cache global`);
                    updateProgressBar();
                    return;
                }
                
                // ETAPA 1: Tentar capturar a imagem diretamente do DOM
                const domImageData = captureImageFromDOM(prod.sku);
                if (domImageData) {
                    imageCache.set(prod.sku, domImageData);
                    globalImageCache.set(cacheKey, domImageData);
                    updateProgressBar();
                    return;
                }
                
                // ETAPA 2: Se o produto já tem URL de imagem, tentar usá-la
                if (prod.imgSrc && typeof prod.imgSrc === 'string' && prod.imgSrc.trim() !== '') {
                    const dataUrl = await preloadImageAsBase64(prod.imgSrc, prod.sku);
                    if (dataUrl) {
                        imageCache.set(prod.sku, dataUrl);
                        globalImageCache.set(cacheKey, dataUrl);
                        updateProgressBar();
                        return;
                    }
                }
                
                // ETAPA 3: Tentar diferentes URLs possíveis
                const imageUrl = await tryMultipleImageUrls(prod.sku, baseUrls, pdfGenerationState.retryCount[prod.sku]);
                
                if (imageUrl) {
                    // Atualizar a URL da imagem do produto
                    prod.imgSrc = imageUrl;
                    
                    // Pré-carregar e converter para base64
                    const dataUrl = await preloadImageAsBase64(imageUrl, prod.sku);
                    if (dataUrl) {
                        imageCache.set(prod.sku, dataUrl);
                        globalImageCache.set(cacheKey, dataUrl);
                        updateProgressBar();
                        return;
                    }
                }
                
                // ETAPA 4: Último recurso - criar um placeholder com o SKU do produto
                console.warn(`Não foi possível carregar imagem para SKU ${prod.sku}, usando placeholder`);
                const placeholderUrl = `https://via.placeholder.com/300x300?text=${encodeURIComponent(prod.sku)}`;
                const placeholderDataUrl = await preloadImageAsBase64(placeholderUrl, prod.sku);
                
                if (placeholderDataUrl) {
                    imageCache.set(prod.sku, placeholderDataUrl);
                    globalImageCache.set(cacheKey, placeholderDataUrl);
                }
                
                // Atualizar barra de progresso
                updateProgressBar();
            } catch (error) {
                console.error(`Erro ao processar imagem para ${prod.sku}:`, error);
                updateProgressBar();
            }
        })(product);
        
        imageTasks.push(task);
    }
    
    // Função para atualizar a barra de progresso
    function updateProgressBar() {
        pdfGenerationState.processedItems++;
        const percentage = Math.round((pdfGenerationState.processedItems / pdfGenerationState.totalItems) * 100);
        
        // Atualizar visualmente a barra de progresso
        const progressFill = document.getElementById('pdf-progress-fill');
        const progressText = document.getElementById('pdf-progress-text');
        
        progressFill.style.width = `${percentage}%`;
        progressText.textContent = `Carregando imagens: ${percentage}%`;
        
        // Verificar se completou
        if (pdfGenerationState.processedItems >= pdfGenerationState.totalItems) {
            progressText.textContent = `${imageCache.size} de ${pdfGenerationState.totalItems} imagens carregadas (${percentage}%)`;
        }
    }
    
    // Processar todas as imagens em paralelo, com timeout maior (30 segundos)
    const timeoutPromise = new Promise(resolve => setTimeout(() => {
        console.warn("Timeout global de carregamento de imagens atingido (30 segundos)");
        resolve();
    }, 30000)); // 30 segundos no máximo
    
    await Promise.race([
        Promise.all(imageTasks),
        timeoutPromise
    ]);
    
    // Tentar novamente para imagens que falharam (forçando o último recurso)
    const failedSkus = products.filter(p => !imageCache.has(p.sku)).map(p => p.sku);
    
    if (failedSkus.length > 0) {
        console.log(`Tentando novamente para ${failedSkus.length} imagens que falharam...`);
        
        const retryTasks = failedSkus.map(sku => {
            const product = products.find(p => p.sku === sku);
            return (async () => {
                // Forçar placeholder para SKUs que falharam
                const placeholderUrl = `https://via.placeholder.com/300x300?text=${encodeURIComponent(sku)}`;
                const placeholderDataUrl = await preloadImageAsBase64(placeholderUrl, sku);
                
                if (placeholderDataUrl) {
                    imageCache.set(sku, placeholderDataUrl);
                    globalImageCache.set(`img_${sku}`, placeholderDataUrl);
                    console.log(`Placeholder adicionado para SKU ${sku}`);
                }
            })();
        });
        
        await Promise.all(retryTasks);
    }
    
    // Salvar cache global no localStorage
    try {
        const cacheObject = Object.fromEntries(globalImageCache);
        localStorage.setItem('imageCache', JSON.stringify(cacheObject));
    } catch (storageError) {
        console.warn("Não foi possível salvar o cache de imagens:", storageError);
    }
    
    // Marcar processo como concluído
    pdfGenerationState.inProgress = false;
    
    console.log(`Processo de carregamento de imagens concluído. ${imageCache.size} de ${products.length} imagens carregadas.`);
    return imageCache;
}

// Função melhorada para criar placeholder de imagem
function createPlaceholderImage(doc, product, imgX, imgY, imgWidth, imgHeight) {
    // Usar diferentes cores para diferentes categorias
    let fillColor = [240, 240, 240]; // Cinza claro padrão
    const category = (product.category || '').toLowerCase();
    
    if (category.includes('chocolate') || category.includes('acaiteria')) {
        fillColor = [222, 184, 135]; // Marrom claro para chocolates
    } else if (category.includes('confeitaria')) {
        fillColor = [255, 182, 193]; // Rosa claro para confeitaria
    } else if (category.includes('ingrediente')) {
        fillColor = [240, 230, 140]; // Amarelo claro para ingredientes
    } else if (category.includes('embalagem')) {
        fillColor = [176, 224, 230]; // Azul claro para embalagens
    }
    
    // Adicionar retângulo colorido como fundo da imagem
    doc.setFillColor(fillColor[0], fillColor[1], fillColor[2]);
    doc.rect(imgX, imgY, imgWidth, imgHeight, 'F');
    
    // Adicionar borda
    doc.setDrawColor(200, 200, 200);
    doc.rect(imgX, imgY, imgWidth, imgHeight, 'S');
    
    // Destacar o SKU no placeholder para facilitar identificação
    doc.setFontSize(7);
    doc.setTextColor(80, 80, 80);
    doc.setFont('helvetica', 'bold');
    doc.text(product.sku || "SKU", imgX + imgWidth/2, imgY + 7, {align: "center"});
    
    // Criar representação visual do produto baseada na categoria
    doc.setDrawColor(100, 100, 100);
    doc.setLineWidth(0.7);
    
    // Crie ícones diferentes dependendo do tipo de produto
    if (product.name && product.name.toLowerCase().includes('chocolate')) {
        // Desenhar uma barra de chocolate
        doc.setFillColor(82, 44, 26); // Marrom mais escuro
        doc.rect(imgX + 5, imgY + 10, 15, 10, 'F');
        doc.setDrawColor(60, 30, 15);
        doc.line(imgX + 5, imgY + 15, imgX + 20, imgY + 15);
        doc.line(imgX + 12.5, imgY + 10, imgX + 12.5, imgY + 20);
    }
    else if (product.name && product.name.toLowerCase().includes('granulado')) {
        // Desenhar pontos para granulado
        doc.setFillColor(60, 30, 15);
        for (let i = 0; i < 12; i++) {
            const dotX = imgX + 5 + (i % 4) * 5;
            const dotY = imgY + 12 + Math.floor(i / 4) * 5;
            doc.circle(dotX, dotY, 1, 'F');
        }
    }
    else if (product.name && product.name.toLowerCase().includes('cobertura')) {
        // Desenhar uma tigela com cobertura
        doc.setDrawColor(80, 80, 80);
        doc.setFillColor(220, 220, 220);
        // Tigela
        doc.ellipse(imgX + imgWidth/2, imgY + imgHeight/2 + 2, 8, 3, 'F');
        doc.ellipse(imgX + imgWidth/2, imgY + imgHeight/2 + 2, 8, 3, 'S');
        // Cobertura derretida
        doc.setFillColor(100, 50, 30);
        doc.ellipse(imgX + imgWidth/2, imgY + imgHeight/2, 7, 2, 'F');
        // Pauzinho de chocolate
        doc.setFillColor(60, 30, 15);
        doc.rect(imgX + imgWidth/2 - 0.5, imgY + 10, 1, 8, 'F');
    } 
    else {
        // Ícone genérico para outros produtos
        // Desenhar caixa de produto
        doc.setDrawColor(120, 120, 120);
        doc.rect(imgX + 5, imgY + 12, 15, 10, 'S');
        doc.line(imgX + 5, imgY + 16, imgX + 20, imgY + 16);
        doc.setFontSize(6);
        doc.setTextColor(80, 80, 80);
        doc.text("PRODUTO", imgX + imgWidth/2, imgY + imgHeight/2 + 6, {align: "center"});
    }
    
    // Resetar estilos
    doc.setLineWidth(0.1);
    doc.setDrawColor(0, 0, 0);
}

// Função auxiliar para adicionar um produto ao documento PDF
async function addProductToDocument(doc, product, y, margin, contentWidth, options, imageCache) {
    const { includeSku, includeCategory, includePrice, includePriceField, includeImages } = options;
    const productWidth = contentWidth;
    const pageWidth = doc.internal.pageSize.getWidth();
    
    // Definir altura do produto
    let productHeight = 35; // Altura padrão para todos os produtos
    
    // Desenhar caixa do produto
    doc.setFillColor(250, 250, 250);
    doc.setDrawColor(230, 230, 230);
    doc.rect(margin, y, productWidth, productHeight, 'F');
    doc.rect(margin, y, productWidth, productHeight, 'S');
    
    // Adicionar imagem ou placeholder
    if (includeImages) {
        try {
            // Dimensões e posição da imagem
            const imgWidth = 25;
            const imgHeight = 25;
            const imgX = margin + 5;
            const imgY = y + 5;
            
            // Verificar se temos a imagem no cache
            let imageData = null;
            if (imageCache && imageCache.has(product.sku)) {
                imageData = imageCache.get(product.sku);
            }
            
            // Se conseguimos a imagem, adicionar ao PDF
            if (imageData) {
                try {
                    doc.addImage(imageData, 'JPEG', imgX, imgY, imgWidth, imgHeight);
                } catch (addImgError) {
                    console.error('Erro ao adicionar imagem ao PDF:', addImgError);
                    // Criar placeholder colorido em caso de erro
                    createPlaceholderImage(doc, product, imgX, imgY, imgWidth, imgHeight);
                }
            } else {
                // Criar placeholder colorido se não conseguimos a imagem
                createPlaceholderImage(doc, product, imgX, imgY, imgWidth, imgHeight);
            }
            
            // Nome do produto
            doc.setFontSize(11);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(0, 0, 0);
            const nameText = product.name || 'Produto sem nome';
            doc.text(nameText, margin + 35, y + 10);
            
            // SKU
            let textY = y + 16;
            if (includeSku) {
                doc.setFontSize(9);
                doc.setFont('helvetica', 'normal');
                doc.setTextColor(100, 100, 100);
                doc.text(`Código: ${product.sku}`, margin + 35, textY);
                textY += 5;
            }
            
            // Categoria
            if (includeCategory) {
                doc.setFontSize(9);
                doc.setFont('helvetica', 'normal');
                doc.setTextColor(100, 100, 100);
                const categoryText = product.category || 'Sem categoria';
                doc.text(`Categoria: ${categoryText}`, margin + 35, textY);
                textY += 5;
            }
            
            // Preço
            if (includePrice && product.price) {
                doc.setFontSize(10);
                doc.setFont('helvetica', 'bold');
                doc.setTextColor(0, 0, 0);
                doc.text(`Preço: R$ ${product.price}`, margin + 35, textY);
                textY += 5;
            }
            
            // Campo para preço manual
            if (includePriceField && (!includePrice || !product.price)) {
                doc.setFontSize(10);
                doc.setFont('helvetica', 'normal');
                doc.text('Preço: R$ __________________', margin + 35, textY);
            }
        } catch (error) {
            console.error('Erro ao processar produto:', error);
            
            // Em caso de erro, mostrar só o texto
            doc.setFontSize(11);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(0, 0, 0);
            const nameText = product.name || 'Produto sem nome';
            doc.text(nameText, margin + 10, y + 10);
            
            // Informações em linha
            const infoY = y + 18;
            let infoX = margin + 10;
            
            // SKU
            if (includeSku) {
                doc.setFontSize(9);
                doc.setFont('helvetica', 'normal');
                doc.setTextColor(100, 100, 100);
                doc.text(`Código: ${product.sku}`, infoX, infoY);
                infoX += 45;
            }
            
            // Categoria
            if (includeCategory) {
                doc.setFontSize(9);
                doc.setFont('helvetica', 'normal');
                doc.setTextColor(100, 100, 100);
                const categoryText = product.category || 'Sem categoria';
                doc.text(`Categoria: ${categoryText}`, infoX, infoY);
                infoX += 65;
            }
            
            // Preço
            if (includePrice && product.price) {
                doc.setFontSize(10);
                doc.setFont('helvetica', 'bold');
                doc.setTextColor(0, 0, 0);
                doc.text(`Preço: R$ ${product.price}`, infoX, infoY);
            } else if (includePriceField) {
                doc.setFontSize(10);
                doc.setFont('helvetica', 'normal');
                doc.text('Preço: R$ __________________', infoX, infoY);
            }
        }
    } else {
        // Layout simplificado sem imagens
        // Nome do produto
        doc.setFontSize(11);
        doc.setFont('helvetica', 'bold');
        doc.setTextColor(0, 0, 0);
        const nameText = product.name || 'Produto sem nome';
        doc.text(nameText, margin + 5, y + 10);
        
        // Informações em linha
        const infoY = y + 18;
        let infoX = margin + 5;
        
        // SKU
        if (includeSku) {
            doc.setFontSize(9);
            doc.setFont('helvetica', 'normal');
            doc.setTextColor(100, 100, 100);
            doc.text(`Código: ${product.sku}`, infoX, infoY);
            infoX += 45;
        }
        
        // Categoria
        if (includeCategory) {
            doc.setFontSize(9);
            doc.setFont('helvetica', 'normal');
            doc.setTextColor(100, 100, 100);
            const categoryText = product.category || 'Sem categoria';
            doc.text(`Categoria: ${categoryText}`, infoX, infoY);
            infoX += 65;
        }
        
        // Preço
        if (includePrice && product.price) {
            doc.setFontSize(10);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(0, 0, 0);
            doc.text(`Preço: R$ ${product.price}`, infoX, infoY);
        } else if (includePriceField) {
            doc.setFontSize(10);
            doc.setFont('helvetica', 'normal');
            doc.text('Preço: R$ __________________', infoX, infoY);
        }
    }
    
    return productHeight;
}

// Função para gerar PDF da coleção atual
async function generatePDF() {
    // Verificar se já temos um processo em andamento
    if (pdfGenerationState.inProgress) {
        showNotification('Já existe um processo de geração de PDF em andamento. Aguarde...', 'error');
        return;
    }
    
    // Desabilitar o botão para evitar múltiplos cliques
    document.getElementById('generate-pdf-btn').disabled = true;
    
    // Obter o título do PDF
    const title = document.getElementById('pdf-collection-name').value.trim() || 'Catálogo de Produtos';
    const collectionName = document.getElementById('collection-name').value.trim();
    
    // Se temos um nome da coleção, usá-lo como subtítulo
    const useCollectionName = collectionName && collectionName !== title;
    
    // Obter todas as configurações do PDF
    const includeSku = document.getElementById('include-sku').checked;
    const includeCategory = document.getElementById('include-category').checked;
    const includePrice = document.getElementById('include-price').checked;
    const includePriceField = document.getElementById('include-price-field').checked;
    const groupByCategory = document.getElementById('group-by-category').checked;
    const includeLogo = document.getElementById('include-logo').checked;
    const includeImages = document.getElementById('include-images').checked;
    const includeFooter = document.getElementById('include-footer').checked;
    
    // Mostrar notificação de geração
    showNotification('Carregando imagens e gerando PDF. Aguarde...', 'success');
    
    // Pré-carregar todas as imagens antes de gerar o PDF
    (async () => {
        try {
            // Tentar buscar e pré-carregar imagens para todos os produtos
            const imageCache = await preloadAllImages(selectedProducts);
            console.log(`Imagens pré-carregadas: ${imageCache.size} de ${selectedProducts.length}`);
            
            // Criar uma instância do jsPDF
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF({
                orientation: 'portrait',
                unit: 'mm',
                format: 'a4',
                compress: true
            });
            
            // Definir metadados do PDF para evitar bloqueios de segurança
            doc.setProperties({
                title: title,
                subject: useCollectionName ? collectionName : 'Catálogo de Produtos Ameripan',
                author: 'Ameripan',
                keywords: 'catalogo, produtos, ameripan',
                creator: 'Catálogo Ameripan',
                producer: 'Ameripan'
            });
            
            // Definir margens e valores padrão
            const pageWidth = doc.internal.pageSize.getWidth();
            const pageHeight = doc.internal.pageSize.getHeight();
            const margin = 15;
            const contentWidth = pageWidth - (margin * 2);
            let y = margin;
            
            // Adicionar cabeçalho com logo
            if (includeLogo) {
                // Adicionar logo (retângulo com textura/gradiente)
                // Fundo do logo
                doc.setFillColor(240, 240, 240);
                doc.rect(margin, y, 40, 15, 'F');
                
                // Borda logo
                doc.setDrawColor(220, 220, 220);
                doc.rect(margin, y, 40, 15, 'S');
                
                // Texto logo
                doc.setFontSize(12);
                doc.setTextColor(50, 50, 50);
                doc.setFont('helvetica', 'bold');
                doc.text('AMERIPAN', margin + 20, y + 8, { align: 'center' });
                
                // Adicionar título do catálogo
                doc.setFontSize(18);
                doc.setFont('helvetica', 'bold');
                doc.setTextColor(0, 0, 0);
                doc.text(title, pageWidth - margin, y + 8, { align: 'right' });
                
                // Se houver um nome de coleção diferente do título, adicionar como subtítulo
                if (useCollectionName) {
                    y += 14;
                    doc.setFontSize(12);
                    doc.setFont('helvetica', 'italic');
                    doc.setTextColor(80, 80, 80);
                    doc.text(`Coleção: ${collectionName}`, pageWidth - margin, y, { align: 'right' });
                    y += 4;
                } else {
                    y += 18;
                }
                
                // Linha separadora
                doc.setDrawColor(200, 200, 200);
                doc.line(margin, y, pageWidth - margin, y);
                y += 10;
            } else {
                // Adicionar apenas o título centralizado
                doc.setFontSize(22);
                doc.setFont('helvetica', 'bold');
                doc.text(title, pageWidth / 2, y + 8, { align: 'center' });
                
                // Se houver um nome de coleção diferente do título, adicionar como subtítulo
                if (useCollectionName) {
                    y += 14;
                    doc.setFontSize(14);
                    doc.setFont('helvetica', 'italic');
                    doc.setTextColor(80, 80, 80);
                    doc.text(`Coleção: ${collectionName}`, pageWidth / 2, y, { align: 'center' });
                    y += 6;
                } else {
                    y += 20;
                }
            }
            
            // Obter data atual
            const today = new Date();
            const dateStr = today.toLocaleDateString('pt-BR');
            doc.setFontSize(10);
            doc.setFont('helvetica', 'italic');
            doc.setTextColor(100, 100, 100);
            doc.text(`Gerado em: ${dateStr}`, pageWidth - margin, y, { align: 'right' });
            y += 8;
            
            // Adicionar informação sobre as imagens e cache
            if (includeImages) {
                const imagesLoaded = imageCache.size;
                const totalProducts = selectedProducts.length;
                
                // Adicionar informação sobre imagens carregadas apenas se não foram todas carregadas
                if (imagesLoaded < totalProducts && imagesLoaded > 0) {
                    doc.setFontSize(8);
                    doc.setFont('helvetica', 'italic');
                    doc.setTextColor(150, 150, 150);
                    doc.text(`* ${imagesLoaded} de ${totalProducts} imagens disponíveis`, margin, y, { align: 'left' });
                    y += 5;
                }
            }
            
            // Se agrupar por categoria
            if (groupByCategory) {
                // Organizar produtos por categoria
                const categoriesMap = {};
                selectedProducts.forEach(product => {
                    const category = product.category || 'Sem categoria';
                    if (!categoriesMap[category]) {
                        categoriesMap[category] = [];
                    }
                    categoriesMap[category].push(product);
                });
                
                // Processar cada categoria
                for (const category in categoriesMap) {
                    // Verificar se é necessário adicionar nova página
                    if (y > pageHeight - 50) {
                        doc.addPage();
                        y = margin;
                    }
                    
                    // Adicionar título da categoria
                    doc.setFontSize(14);
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(52, 152, 219);
                    doc.text(category.toUpperCase(), margin, y);
                    
                    y += 2;
                    doc.setDrawColor(52, 152, 219);
                    doc.line(margin, y, margin + 40, y);
                    y += 10;
                    
                    // Adicionar produtos desta categoria
                    for (const product of categoriesMap[category]) {
                        const productHeight = await addProductToDocument(doc, product, y, margin, contentWidth, {
                            includeSku,
                            includeCategory,
                            includePrice,
                            includePriceField,
                            includeImages
                        }, imageCache);
                        
                        y += productHeight + 5; // 5mm de espaço entre produtos
                        
                        // Verificar se é necessário adicionar nova página para o próximo produto
                        if (y > pageHeight - 50) {
                            doc.addPage();
                            y = margin;
                        }
                    }
                    
                    y += 5; // Espaço adicional entre categorias
                }
            } else {
                // Adicionar produtos sem agrupar
                for (const product of selectedProducts) {
                    // Verificar se é necessário adicionar nova página
                    if (y > pageHeight - 50) {
                        doc.addPage();
                        y = margin;
                    }
                    
                    const productHeight = await addProductToDocument(doc, product, y, margin, contentWidth, {
                        includeSku,
                        includeCategory,
                        includePrice,
                        includePriceField,
                        includeImages
                    }, imageCache);
                    
                    y += productHeight + 5; // 5mm de espaço entre produtos
                }
            }
            
            // Adicionar rodapé se solicitado
            if (includeFooter) {
                // Adicionar a todas as páginas
                const totalPages = doc.internal.getNumberOfPages();
                for (let i = 1; i <= totalPages; i++) {
                    doc.setPage(i);
                    
                    const footerY = pageHeight - 10;
                    doc.setFontSize(8);
                    doc.setTextColor(100, 100, 100);
                    doc.setFont('helvetica', 'normal');
                    
                    // Linha separadora do rodapé
                    doc.setDrawColor(200, 200, 200);
                    doc.line(margin, footerY - 5, pageWidth - margin, footerY - 5);
                    
                    // Texto do rodapé
                    doc.text(' www.ameripan.com.br | atendimento@ameripan.com.br | (19) 3406-4070', pageWidth / 2, footerY, { align: 'center' });
                    
                    // Número de página
                    doc.text(`Página ${i} de ${totalPages}`, pageWidth - margin, footerY, { align: 'right' });
                }
            }
            
            // Salvar o PDF com o título como nome do arquivo
            const filename = (useCollectionName ? collectionName : title).replace(/[^a-z0-9]/gi, '_').toLowerCase() + '.pdf';
            
            try {
                // Método usando blob e URL (mais confiável)
                const blob = doc.output('blob');
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = filename;
                document.body.appendChild(link);
                link.click();
                
                // Remover o link após o download
                setTimeout(() => {
                    document.body.removeChild(link);
                    URL.revokeObjectURL(url);
                    
                    // Notificar sucesso
                    showNotification('PDF gerado com sucesso!', 'success');
                    
                    // Mostrar instruções sobre erro de segurança apenas se houve erro no cache
                    if (imageCache.size < selectedProducts.length) {
                        setTimeout(() => {
                            showPdfInstructions();
                        }, 1000);
                    }
                }, 100);
            } catch (blobError) {
                console.error('Erro ao baixar PDF via blob:', blobError);
                
                // Método alternativo
                try {
                    doc.save(filename);
                    showNotification('PDF gerado com sucesso!', 'success');
                } catch (saveError) {
                    console.error('Erro ao salvar PDF:', saveError);
                    showNotification('Erro ao gerar PDF. Tente novamente.', 'error');
                }
            }
            
            // Fechar o modal
            closeModal('pdfModal');
            
        } catch (error) {
            console.error('Erro ao gerar PDF:', error);
            showNotification('Erro ao gerar PDF. Tente novamente.', 'error');
            
            // Reativar o botão
            document.getElementById('generate-pdf-btn').disabled = false;
        }
    })();
}

// Função para mostrar instruções de como lidar com o erro de segurança do PDF
function showPdfInstructions() {
    // Criar modal com instruções
    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.id = 'pdfInstructionsModal';
    modal.style.display = 'flex';
    
    const modalContent = `
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-header">
                <div class="modal-title">Como abrir o PDF gerado</div>
                <div class="modal-close" onclick="closeModal('pdfInstructionsModal')">&times;</div>
            </div>
            <div class="modal-body">
                <div style="text-align: center; margin-bottom: 15px;">
                    <img src="https://via.placeholder.com/550x150?text=Erro+de+Seguranca+do+Windows" style="max-width: 100%;">
                </div>
                
                <p><strong>Se você encontrar um erro de segurança ao abrir o PDF:</strong></p>
                
                <ol style="margin-left: 20px; line-height: 1.6;">
                    <li>Clique com o botão direito no arquivo PDF baixado</li>
                    <li>Selecione "Propriedades"</li>
                    <li>Na parte inferior da janela de Propriedades, marque a opção "Desbloquear" (ou "Permitir")</li>
                    <li>Clique em "Aplicar" e "OK"</li>
                    <li>Agora tente abrir o arquivo novamente</li>
                </ol>
                
                <p style="margin-top: 15px;">Alternativamente, você pode:</p>
                
                <ul style="margin-left: 20px; line-height: 1.6;">
                    <li>Clicar em "Mais informações" no aviso de segurança e escolher "Executar assim mesmo"</li>
                    <li>Mover o arquivo para outro local do seu computador antes de abri-lo</li>
                    <li>Usar um navegador diferente para gerar o PDF</li>
                </ul>
                
                <p style="margin-top: 15px; font-style: italic;">Este erro ocorre porque o Windows está protegendo seu computador contra arquivos potencialmente não seguros da internet.</p>
            </div>
            <div style="padding: 15px; text-align: right;">
                <button class="modal-btn save" onclick="closeModal('pdfInstructionsModal')">Entendi</button>
            </div>
        </div>
    `;
    
    modal.innerHTML = modalContent;
    document.body.appendChild(modal);
    
    // Animar a abertura do modal
    setTimeout(() => {
        modal.classList.add('active');
    }, 10);
    
    // Fechar modal ao clicar fora
    modal.addEventListener('click', function(e) {
        if (e.target === this) {
            closeModal('pdfInstructionsModal');
        }
    });
}

// Exibir notificação
function showNotification(message, type = 'success') {
    const notifications = document.getElementById('notifications');
    
    const notification = document.createElement('div');
    notification.classList.add('notification');
    notification.classList.add(type);
    
    if (type === 'error') {
        notification.innerHTML = `<i class="fas fa-exclamation-circle"></i> ${message}`;
    } else {
        notification.innerHTML = `<i class="fas fa-check-circle"></i> ${message}`;
    }
    
    notifications.appendChild(notification);
    
    // Mostrar com animação
    setTimeout(() => {
        notification.classList.add('show');
    }, 10);
    
    // Auto-remover após 3 segundos
    setTimeout(() => {
        notification.classList.remove('show');
        setTimeout(() => {
            notifications.removeChild(notification);
        }, 300);
    }, 3000);
}

// Funções para controle de modal
function openModal(modalId) {
    const modal = document.getElementById(modalId);
    modal.style.display = "flex";
    
    // Animar a abertura do modal
    setTimeout(() => {
        modal.classList.add('active');
    }, 10);
    
    // Impedir o scroll da página
    document.body.style.overflow = 'hidden';
}

function closeModal(modalId) {
    const modal = document.getElementById(modalId);
    modal.classList.remove('active');
    
    // Após a animação de fechamento
    setTimeout(() => {
        modal.style.display = "none";
    }, 300);
    
    // Restaurar o scroll da página
    document.body.style.overflow = 'auto';
}

// Configuração do scroll infinito otimizado
function setupInfiniteScroll() {
    // Usar Intersection Observer para detectar quando o usuário chega ao final da página
    const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            if (entry.isIntersecting && !isLoading) {
                loadMoreProducts(false); // false = sem atraso artificial
            }
        });
    }, { 
        rootMargin: `0px 0px ${scrollThreshold}px 0px`, // Começar a carregar antes de chegar ao final
        threshold: 0.1 
    });
    
    const loader = document.createElement('div');
    loader.id = 'infinite-scroll-trigger';
    loader.style.height = '20px';
    document.getElementById('product-list').after(loader);
    
    observer.observe(loader);
    
    // Pré-carregamento: começar a carregar mais produtos logo após a primeira exibição
    setTimeout(() => {
        if (productData.length > visibleProducts) {
            // Pré-carregar o próximo lote silenciosamente
            preloadNextBatch();
        }
    }, 1000);
    
    // Otimização para scroll rápido: detectar quando o usuário está rolando rapidamente
    let lastScrollTop = 0;
    let scrollSpeed = 0;
    
    window.addEventListener('scroll', () => {
        const scrollTop = window.scrollY;
        scrollSpeed = Math.abs(scrollTop - lastScrollTop);
        lastScrollTop = scrollTop;
        
        // Se o usuário está rolando rapidamente, carregar mais produtos antecipadamente
        if (scrollSpeed > 50 && !isLoading && (window.innerHeight + window.scrollY) > document.body.offsetHeight - 1000) {
            loadMoreProducts(false);
        }
    });
}

// Adicionar loader (otimizado para usar menos recursos)
function addInfiniteScrollLoader() {
    // Verificar se há mais produtos para carregar
    if (productData.length > visibleProducts) {
        // Verificar se o loader já existe para evitar duplicatas
        if (!document.getElementById('products-loader')) {
            const loader = document.createElement('div');
            loader.className = 'loading-spinner';
            loader.id = 'products-loader';
            loader.innerHTML = '<div class="spinner"></div>';
            document.getElementById('product-list').appendChild(loader);
        }
    }
}

// Carrega mais produtos com otimização para desempenho
function loadMoreProducts(withDelay = false) {
    if (isLoading || productData.length <= visibleProducts) return;
    
    isLoading = true;
    
    // Remover o loader existente
    const existingLoader = document.getElementById('products-loader');
    if (existingLoader) {
        existingLoader.remove();
    }
    
    // Função a ser executada para carregar mais produtos
    const loadFunction = () => {
        // Use os elementos pré-carregados se disponíveis
        if (window.preloadedElements) {
            appendPreloadedElements();
        } else {
            // Caso não tenhamos elementos pré-carregados, use o método tradicional
            visibleProducts += incrementAmount;
            displayProducts();
        }
        
        isLoading = false;
        
        // Pré-carregar o próximo lote para rolagem contínua
        setTimeout(() => {
            if (productData.length > visibleProducts) {
                preloadNextBatch();
            }
        }, 200);
    };
    
    // Executar imediatamente ou com um delay mínimo
    if (withDelay) {
        setTimeout(loadFunction, 100); // Delay reduzido de 500ms para 100ms
    } else {
        loadFunction();
    }
}

// Controle do botão "Voltar ao Topo"
window.addEventListener('scroll', function() {
    const backToTopButton = document.getElementById('backToTop');
    if (window.scrollY > 300) {
        backToTopButton.classList.add('visible');
    } else {
        backToTopButton.classList.remove('visible');
    }
});

function scrollToTop() {
    window.scrollTo({
        top: 0,
        behavior: 'smooth'
    });
}

// Configurar eventos de filtros
document.getElementById("search").addEventListener("input", (e) => {
    visibleProducts = 20; // Resetar ao filtrar
    displayProducts(e.target.value);
});

document.getElementById("category").addEventListener("change", (e) => {
    visibleProducts = 20; // Resetar ao filtrar
    displayProducts(null, e.target.value);
});

document.getElementById("sort").addEventListener("change", (e) => {
    visibleProducts = 20; // Resetar ao filtrar
    displayProducts(null, null, e.target.value);
});

document.getElementById("package-size").addEventListener("change", (e) => {
    visibleProducts = 20; // Resetar ao filtrar
    displayProducts(null, null, null, e.target.value);
});

// Fechar os modais ao clicar fora do conteúdo
document.querySelectorAll(".modal").forEach(modal => {
    modal.addEventListener("click", function(e) {
        if (e.target === this) {
            closeModal(this.id);
        }
    });
});

// Fechar modais com a tecla ESC
document.addEventListener("keydown", function(e) {
    if (e.key === "Escape") {
        document.querySelectorAll(".modal").forEach(modal => {
            if (modal.style.display === "flex") {
                closeModal(modal.id);
            }
        });
    }
}); 

// Variáveis para controlar o comportamento de rolagem do header
let lastScrollTop = 0;
const header = document.querySelector('header');


// Função para controlar a visibilidade do header durante a rolagem
function handleHeaderScroll() {
    const currentScroll = window.scrollY || document.documentElement.scrollTop;
    
    // Verificar se rolou mais que o threshold para evitar micro-movimentos
    if (Math.abs(currentScroll - lastScrollTop) > scrollThreshold) {
        // Se rolou para baixo e já passou da altura do header
        if (currentScroll > lastScrollTop && currentScroll > header.offsetHeight) {
            // Esconder o header
            header.classList.add('hide');
        } else {
            // Rolou para cima, mostrar o header
            header.classList.remove('hide');
        }
        
        // Atualizar a última posição de rolagem
        lastScrollTop = currentScroll;
    }
}

// Modificar o addEventListener de scroll existente
window.addEventListener('scroll', function() {
    const backToTopButton = document.getElementById('backToTop');
    if (window.scrollY > 300) {
        backToTopButton.classList.add('visible');
    } else {
        backToTopButton.classList.remove('visible');
    }
    
    // Chamar a função para controlar o header
    handleHeaderScroll();
});

// Também mostrar o header quando o mouse está próximo ao topo da página
document.addEventListener('mousemove', function(e) {
    if (e.clientY < 20 && header.classList.contains('hide')) {
        header.classList.remove('hide');
    }
});


document.addEventListener('DOMContentLoaded', function() {
    const mainSearchInput = document.getElementById('search');
    const headerSearchInput = document.getElementById('header-search');
    
    // Atualizar placeholder e título para ambos os campos
    const placeholder = 'Buscar por nome ou SKU (separe por vírgula)';
    const title = 'Digite um ou mais termos separados por vírgula. Ex: chocolate, 500g, mavalério';
    
    mainSearchInput.setAttribute('placeholder', placeholder);
    mainSearchInput.setAttribute('title', title);
    headerSearchInput.setAttribute('placeholder', placeholder);
    headerSearchInput.setAttribute('title', title);
    
    // Sincronizar os campos de busca
    headerSearchInput.addEventListener('input', function(e) {
        mainSearchInput.value = e.target.value;
        displayProducts(e.target.value);
    });
    
    mainSearchInput.addEventListener('input', function(e) {
        headerSearchInput.value = e.target.value;
        displayProducts(e.target.value);
    });
});

/////new function 
// Esse script deve ser adicionado APÓS a inicialização completa da página
// Adicione-o no final da tag </body>, como um script separado

// Função para aguardar a definição de variáveis importantes
function waitForAppInit(callback, maxAttempts = 20) {
    let attempts = 0;
    const checkInterval = setInterval(() => {
        attempts++;
        
        // Verificar se as variáveis necessárias já foram definidas
        if (window.allProducts && window.productData && window.displayProducts) {
            clearInterval(checkInterval);
            console.log("Aplicação inicializada, aplicando melhorias");
            callback();
            return;
        }
        
        // Limite de tentativas para evitar loop infinito
        if (attempts >= maxAttempts) {
            clearInterval(checkInterval);
            console.warn("Tempo limite excedido aguardando inicialização");
        }
    }, 300);
}

// Iniciar a aplicação apenas quando a página estiver completamente carregada e pronta
window.addEventListener('load', function() {
    // Aguardar inicialização das variáveis essenciais antes de aplicar melhorias
    waitForAppInit(function() {
        initAppEnhancements();
    });
});

// Função para inicializar todas as melhorias
function initAppEnhancements() {
    // 1. Adicionar campo de busca no header
    addHeaderSearch();
    
    // 2. Configurar controle do header durante rolagem
    setupHeaderScroll();
    
    // 3. Carregar preferência de visualização
    loadViewPreference();
    
    // 4. Adicionar botão para alternar visualização
    addViewToggleButton();
    
    // 5. Melhorar a função de busca multi-termo (com segurança extra)
    setupMultiTermSearch();
    
    // 6. Configurar carregamento otimizado de imagens
    setupLazyImageLoading();
}

// Funções para a barra de busca no header
function addHeaderSearch() {
    const headerControls = document.querySelector('.header-controls');
    if (headerControls) {
        // Verificar se já existe uma barra de pesquisa no header
        if (headerControls.querySelector('.header-search')) {
            return;
        }
        
        const headerSearch = document.createElement('div');
        headerSearch.className = 'header-search';
        headerSearch.innerHTML = `
            <div class="search-container">
                <i class="fas fa-search search-icon"></i>
                <input type="text" id="header-search" placeholder="Buscar por nome ou SKU (separe por vírgula)">
            </div>
        `;
        headerControls.insertBefore(headerSearch, headerControls.firstChild);
        
        // Sincronizar os campos de busca
        const mainSearchInput = document.getElementById('search');
        const headerSearchInput = document.getElementById('header-search');
        
        if (mainSearchInput && headerSearchInput) {
            // Atualizar placeholder e título
            const placeholder = 'Buscar por nome ou SKU (separe por vírgula)';
            const title = 'Digite um ou mais termos separados por vírgula. Ex: chocolate, 500g, mavalério';
            
            mainSearchInput.setAttribute('placeholder', placeholder);
            mainSearchInput.setAttribute('title', title);
            headerSearchInput.setAttribute('placeholder', placeholder);
            headerSearchInput.setAttribute('title', title);
            
            // Inicialmente sincronizar o campo do header com o campo principal
            headerSearchInput.value = mainSearchInput.value;
            
            // Sincronizar os campos de busca
            headerSearchInput.addEventListener('input', function(e) {
                mainSearchInput.value = e.target.value;
                if (typeof window.displayProducts === 'function') {
                    window.displayProducts(e.target.value);
                }
            });
            
            mainSearchInput.addEventListener('input', function(e) {
                headerSearchInput.value = e.target.value;
            });
        }
    }
}

// Configurar controle do header durante rolagem
function setupHeaderScroll() {
    // Verificar se já existe um handler global para o evento de scroll
    const existingHandler = window.onscroll;
    
    window.onscroll = function(e) {
        // Chamar handler original se existir
        if (typeof existingHandler === 'function') {
            existingHandler(e);
        }
        
        // Adicionar nossa lógica
        const backToTopButton = document.getElementById('backToTop');
        if (backToTopButton) {
            if (window.scrollY > 300) {
                backToTopButton.classList.add('visible');
            } else {
                backToTopButton.classList.remove('visible');
            }
        }
        
        // Chamar a função para controlar o header
        handleHeaderScroll();
    };
    
    // Também mostrar o header quando o mouse está próximo ao topo da página
    document.addEventListener('mousemove', function(e) {
        const header = document.querySelector('header');
        if (header && e.clientY < 20 && header.classList.contains('hide')) {
            header.classList.remove('hide');
        }
    });
}

// Função para controlar a visibilidade do header durante a rolagem
function handleHeaderScroll() {
    const header = document.querySelector('header');
    if (!header) return;
    
    const currentScroll = window.scrollY || document.documentElement.scrollTop;
    
    // Se a variável lastScrollTop não existir, criar uma
    if (typeof window.headerLastScrollTop === 'undefined') {
        window.headerLastScrollTop = 0;
    }
    
    // Threshold para movimento significativo
    const threshold = 50;
    
    // Verificar se rolou mais que o threshold para evitar micro-movimentos
    if (Math.abs(currentScroll - window.headerLastScrollTop) > threshold) {
        // Se rolou para baixo e já passou da altura do header
        if (currentScroll > window.headerLastScrollTop && currentScroll > header.offsetHeight) {
            // Esconder o header
            header.classList.add('hide');
        } else {
            // Rolou para cima, mostrar o header
            header.classList.remove('hide');
        }
        
        // Atualizar a última posição de rolagem
        window.headerLastScrollTop = currentScroll;
    }
}

// Implementar visualização em lista/grade
window.isGridView = true;

window.toggleView = function() {
    window.isGridView = !window.isGridView;
    
    document.querySelectorAll('.products').forEach(container => {
        if (window.isGridView) {
            container.classList.remove('list-view');
        } else {
            container.classList.add('list-view');
        }
    });
    
    // Atualizar o botão de toggle (se existir)
    const viewToggleBtn = document.querySelector('.view-toggle-btn');
    if (viewToggleBtn) {
        const icon = viewToggleBtn.querySelector('i');
        const text = viewToggleBtn.querySelector('span');
        
        if (icon) icon.className = `fas ${window.isGridView ? 'fa-list' : 'fa-th-large'}`;
        if (text) text.textContent = window.isGridView ? 'Lista' : 'Grade';
    }
    
    // Salvar preferência
    localStorage.setItem('gridView', window.isGridView);
    
    // Mostrar notificação se a função existir
    if (typeof window.showNotification === 'function') {
        window.showNotification(`Visualização em ${window.isGridView ? 'grade' : 'lista'} ativada`, 'success');
    }
};

// Carregar preferência de visualização
function loadViewPreference() {
    const savedView = localStorage.getItem('gridView');
    if (savedView !== null) {
        window.isGridView = savedView === 'true';
        if (!window.isGridView) {
            document.querySelectorAll('.products').forEach(container => {
                container.classList.add('list-view');
            });
        }
    }
}

// Adicionar botão para alternar visualização (grade/lista)
function addViewToggleButton() {
    // Verificar se o botão já existe
    if (document.querySelector('.view-toggle')) {
        return;
    }
    
    const filtersMain = document.querySelector('.filters-main');
    if (filtersMain) {
        const viewToggle = document.createElement('div');
        viewToggle.className = 'view-toggle';
        viewToggle.style.marginLeft = 'auto';
        viewToggle.innerHTML = `
            <button class="view-toggle-btn" onclick="toggleView()" title="Alternar entre visualização em grade e lista" style="display: flex; align-items: center; gap: 5px; padding: 8px 15px; border-radius: 50px; background-color: var(--primary-color); color: white; border: none; cursor: pointer;">
                <i class="fas ${window.isGridView ? 'fa-list' : 'fa-th-large'}"></i>
                <span>${window.isGridView ? 'Lista' : 'Grade'}</span>
            </button>
        `;
        filtersMain.appendChild(viewToggle);
    }
}

// Melhorar a função de multi-termos com segurança
function setupMultiTermSearch() {
    // Verificar se temos a função original e as variáveis necessárias
    if (typeof window.displayProducts !== 'function' || 
        typeof window.allProducts === 'undefined' || 
        !Array.isArray(window.allProducts)) {
        console.warn('Variáveis necessárias não encontradas. Não foi possível aplicar busca multi-termo.');
        return;
    }
    
    // Salvar a implementação original
    const originalDisplayProducts = window.displayProducts;
    
    // Substituir com nossa implementação melhorada
    window.displayProducts = function(filter = "", category = "", sort = "", packageSize = "") {
        // Obter valores dos filtros
        filter = filter || document.getElementById("search")?.value || "";
        category = category || document.getElementById("category")?.value || "";
        sort = sort || document.getElementById("sort")?.value || "";
        packageSize = packageSize || document.getElementById("package-size")?.value || "";
        
        try {
            // Processar múltiplos termos de filtro separados por vírgula
            const filterTerms = filter.split(',')
                .map(term => term.trim().toLowerCase())
                .filter(term => term.length > 0);
            
            // Verificar novamente as variáveis no momento da execução
            if (Array.isArray(window.allProducts)) {
                // Filtrar produtos com múltiplos termos
                window.productData = window.allProducts.filter(p => {
                    // Filtro por texto (nome ou SKU) - agora suporta múltiplos termos
                    const textMatch = filterTerms.length === 0 || 
                        filterTerms.some(term => 
                            (p.marca && p.marca.toLowerCase().includes(term)) || 
                            (p.sku && p.sku.toLowerCase().includes(term))
                        );
                    
                    // Filtro por categoria
                    const categoryMatch = !category || p.categoria === category;
                    
                    // Filtro por tamanho da embalagem
                    const packageMatch = !packageSize || 
                        (p.packageSize && p.packageSize.toLowerCase() === packageSize.toLowerCase());
                    
                    // Filtro de coleção ativa
                    const collectionMatch = !window.activeCollectionFilter || 
                        (window.activeCollectionFilter.skus && 
                         window.activeCollectionFilter.skus.includes(p.sku));
                    
                    return textMatch && categoryMatch && packageMatch && collectionMatch;
                });
            }
        } catch (err) {
            console.error('Erro na função de busca multi-termo:', err);
            // Em caso de erro, chamar a função original sem modificações
            return originalDisplayProducts.call(this, filter, category, sort, packageSize);
        }
        
        // Chamar a função original com os mesmos parâmetros
        return originalDisplayProducts.call(this, filter, category, sort, packageSize);
    };
}

// Melhorar carregamento de imagens
function setupLazyImageLoading() {
    // Envolver os elementos <img> existentes com lógica de carregamento lazy
    document.querySelectorAll('.product-img-container img').forEach(img => {
        // Verificar se já aplicamos lazy loading a esta imagem
        if (img.classList.contains('lazy-img')) return;
        
        // Adicionar classe para efeito de fade-in
        img.classList.add('lazy-img');
        
        // Configurar evento de load para adicionar classe quando a imagem carregar
        img.onload = function() {
            img.classList.add('loaded');
        };
    });
}
					
					
					// Código para adicionar um botão mais visível e destacado
function addBetterViewToggleButton() {
    // Remover botão existente se houver
    const existingToggle = document.querySelector('.view-toggle');
    if (existingToggle) existingToggle.remove();
    
    // Criar um botão flutuante
    const toggleButton = document.createElement('div');
    toggleButton.className = 'floating-view-toggle';
    toggleButton.style.cssText = `
        position: fixed;
        right: 20px;
        bottom: 80px;
        z-index: 100;
        background-color: var(--primary-color);
        color: white;
        width: 60px;
        height: 60px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        cursor: pointer;
        transition: all 0.3s;
    `;
    
    toggleButton.innerHTML = `
        <i class="fas ${window.isGridView ? 'fa-list' : 'fa-th-large'}" style="font-size: 22px;"></i>
    `;
    
    toggleButton.addEventListener('click', function() {
        window.toggleView();
        this.querySelector('i').className = `fas ${window.isGridView ? 'fa-list' : 'fa-th-large'}`;
    });
    
    // Adicionar ao body
    document.body.appendChild(toggleButton);
    
    // Adicionar tooltip
    toggleButton.setAttribute('title', 'Alternar visualização');
    
    // Adicionar hover effect
    toggleButton.addEventListener('mouseover', function() {
        this.style.transform = 'scale(1.1)';
    });
    
    toggleButton.addEventListener('mouseout', function() {
        this.style.transform = 'scale(1)';
    });
}

// Chamar esta função após a página carregar
setTimeout(addBetterViewToggleButton, 1000);


// Adicionar esta função ao seu código para mostrar uma transição visual ao mudar a visualização
function showViewTransition(isGrid) {
    // Criar um elemento de transição
    const transition = document.createElement('div');
    transition.className = 'view-transition';
    transition.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(52, 152, 219, 0.1);
        z-index: 9999;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.5s;
    `;
    
    // Adicionar ícone ao centro
    transition.innerHTML = `
        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);">
            <i class="fas ${isGrid ? 'fa-th-large' : 'fa-list'}" 
               style="font-size: 50px; color: var(--primary-color);"></i>
        </div>
    `;
    
    // Adicionar ao body
    document.body.appendChild(transition);
    
    // Animar
    setTimeout(() => { transition.style.opacity = '1'; }, 10);
    setTimeout(() => { transition.style.opacity = '0'; }, 600);
    setTimeout(() => { transition.remove(); }, 1100);
}

// Modificar a função toggleView para chamar esta transição
const originalToggleView = window.toggleView;
window.toggleView = function() {
    // Chamar a função original
    originalToggleView();
    
    // Mostrar a transição
    showViewTransition(window.isGridView);
};

// Criar indicadores de navegação
function createNavigationIndicators() {
  // Indicador de categoria anterior (esquerda)
  const leftIndicator = document.createElement('div');
  leftIndicator.className = 'category-navigation-indicator left';
  leftIndicator.innerHTML = '<i class="fas fa-chevron-left" style="font-size: 24px;"></i>';
  document.body.appendChild(leftIndicator);
  
  // Indicador de próxima categoria (direita)
  const rightIndicator = document.createElement('div');
  rightIndicator.className = 'category-navigation-indicator right';
  rightIndicator.innerHTML = '<i class="fas fa-chevron-right" style="font-size: 24px;"></i>';
  document.body.appendChild(rightIndicator);
  
  return { leftIndicator, rightIndicator };
}

// Função principal para configurar navegação por deslize
function setupCategorySwipeNavigation() {
  // Obter todas as categorias
  const categoryElements = document.querySelectorAll('.category-section');
  if (categoryElements.length <= 1) return; // Não precisa de navegação se houver apenas uma categoria
  
  // Criar os indicadores
  const { leftIndicator, rightIndicator } = createNavigationIndicators();
  
  // Variáveis para rastrear o gesto de deslize
  let touchStartX = 0;
  let touchEndX = 0;
  const minSwipeDistance = 80; // Distância mínima para considerar um deslize
  
  // Índice da categoria atual (começa com 0)
  let currentCategoryIndex = 0;
  
  // Mostrar dica visual na primeira vez
  if (!localStorage.getItem('swipeHintShown')) {
    showSwipeHint();
    localStorage.setItem('swipeHintShown', 'true');
  }
  
  // Adicionar listeners para todo o documento
  document.addEventListener('touchstart', function(e) {
    touchStartX = e.changedTouches[0].screenX;
  }, false);
  
  document.addEventListener('touchmove', function(e) {
    // Mostrar indicadores durante o deslize para feedback visual
    const currentX = e.changedTouches[0].screenX;
    const deltaX = currentX - touchStartX;
    
    // Determinar a direção e exibir o indicador apropriado
    if (Math.abs(deltaX) > 30) {
      if (deltaX > 0 && currentCategoryIndex > 0) {
        leftIndicator.classList.add('active');
        rightIndicator.classList.remove('active');
      } else if (deltaX < 0 && currentCategoryIndex < categoryElements.length - 1) {
        rightIndicator.classList.add('active');
        leftIndicator.classList.remove('active');
      }
    }
  }, false);
  
  document.addEventListener('touchend', function(e) {
    touchEndX = e.changedTouches[0].screenX;
    handleSwipe();
    
    // Ocultar indicadores após o fim do deslize
    setTimeout(() => {
      leftIndicator.classList.remove('active');
      rightIndicator.classList.remove('active');
    }, 500);
  }, false);
  
  // Função para processar o deslize
  function handleSwipe() {
    const swipeDistance = touchEndX - touchStartX;
    
    // Ignorar deslizes muito pequenos
    if (Math.abs(swipeDistance) < minSwipeDistance) return;
    
    // Deslize para a direita -> Categoria anterior
    if (swipeDistance > 0 && currentCategoryIndex > 0) {
      navigateToCategory(currentCategoryIndex - 1);
    }
    // Deslize para a esquerda -> Próxima categoria
    else if (swipeDistance < 0 && currentCategoryIndex < categoryElements.length - 1) {
      navigateToCategory(currentCategoryIndex + 1);
    }
  }
  
  // Função para navegar para uma categoria específica
  function navigateToCategory(index) {
    // Validar o índice
    if (index < 0 || index >= categoryElements.length) return;
    
    // Atualizar o índice atual
    currentCategoryIndex = index;
    
    // Rolar para a categoria
    const categoryElement = categoryElements[index];
    categoryElement.scrollIntoView({
      behavior: 'smooth',
      block: 'start'
    });
    
    // Destacar a categoria atual
    document.querySelectorAll('.category-title').forEach(title => {
      title.classList.remove('active-category');
    });
    
    const categoryTitle = categoryElement.querySelector('.category-title');
    if (categoryTitle) {
      categoryTitle.classList.add('active-category');
      
      // Remover a classe após a animação
      setTimeout(() => {
        categoryTitle.classList.remove('active-category');
      }, 1500);
    }
    
    // Opcionalmente, emitir um feedback tátil
    if (navigator.vibrate) {
      navigator.vibrate(30);
    }
  }
  
  // Função para mostrar dica visual
  function showSwipeHint() {
    const hint = document.createElement('div');
    hint.className = 'swipe-hint';
    hint.innerHTML = '<i class="fas fa-exchange-alt"></i> Deslize para navegar entre categorias';
    document.body.appendChild(hint);
    
    // Remover após 4 segundos
    setTimeout(() => {
      hint.style.opacity = '0';
      setTimeout(() => hint.remove(), 500);
    }, 4000);
  }
  
  // Observar mudanças no DOM para reconhecer novas categorias
  const observer = new MutationObserver(function(mutations) {
    mutations.forEach(function(mutation) {
      if (mutation.type === 'childList' && mutation.addedNodes.length) {
        const newCategories = document.querySelectorAll('.category-section');
        if (newCategories.length !== categoryElements.length) {
          // Recarregar a navegação se o número de categorias mudar
          setTimeout(() => setupCategorySwipeNavigation(), 500);
        }
      }
    });
  });
  
  observer.observe(document.getElementById('product-list'), { childList: true, subtree: true });
}

// Inicializar a navegação por deslize
document.addEventListener('DOMContentLoaded', function() {
  // Aguardar para garantir que todas as categorias estejam carregadas
  setTimeout(setupCategorySwipeNavigation, 1000);
});

// Implementação corrigida do modo de apresentação em tela cheia

// Função auto-executável para evitar conflitos de escopo
(function() {
  // Adicionar estilos diretamente no documento
  function addPresentationStyles() {
    const styleElement = document.createElement('style');
    styleElement.textContent = `
      /* Estilo para o botão de apresentação */
      .presentation-mode-button {
        position: fixed;
        bottom: 20px;
        left: 20px;
        background-color: var(--primary-color);
        color: white;
        width: 50px;
        height: 50px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
        cursor: pointer;
        z-index: 99;
        transition: all 0.3s ease;
        transform: scale(1);
      }
      
      .presentation-mode-button:hover {
        transform: scale(1.1);
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
      }
      
      /* Contêiner de apresentação em tela cheia */
      .presentation-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: var(--bg-primary);
        z-index: 9999;
        display: none;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        transition: opacity 0.5s ease;
        opacity: 0;
      }
      
      .presentation-container.active {
        display: flex;
        opacity: 1;
      }
      
      /* Área principal de produto */
      .presentation-product {
        width: 90%;
        max-width: 1200px;
        height: 80%;
        display: flex;
        align-items: center;
        background-color: var(--bg-secondary);
        border-radius: 20px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15);
        padding: 20px;
        position: relative;
        overflow: hidden;
        animation: fadeScale 0.5s ease;
      }
      
      /* Imagem do produto */
      .presentation-image-container {
        flex: 1;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 20px;
      }
      
      .presentation-image {
        max-width: 100%;
        max-height: 100%;
        object-fit: contain;
        border-radius: 10px;
        transition: transform 0.3s ease;
      }
      
      .presentation-image:hover {
        transform: scale(1.05);
      }
      
      /* Informações do produto */
      .presentation-info {
        flex: 1;
        padding: 30px;
        display: flex;
        flex-direction: column;
        height: 100%;
        overflow-y: auto;
      }
      
      .presentation-sku {
        display: inline-block;
        padding: 5px 15px;
        background-color: rgba(52, 152, 219, 0.1);
        color: var(--primary-color);
        border-radius: 50px;
        font-size: 18px;
        font-weight: 500;
        margin-bottom: 15px;
      }
      
      .presentation-name {
        font-size: 32px;
        font-weight: 600;
        margin-bottom: 15px;
        color: var(--text-color);
      }
      
      .presentation-category {
        font-size: 20px;
        color: var(--text-secondary);
        margin-bottom: 20px;
        text-transform: capitalize;
      }
      
      .presentation-price {
        font-size: 28px;
        font-weight: 600;
        color: var(--accent-color);
        margin: 20px 0;
      }
      
      /* Navegação entre slides */
      .presentation-navigation {
        position: absolute;
        bottom: 20px;
        left: 0;
        width: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 20px;
      }
      
      .presentation-nav-button {
        width: 50px;
        height: 50px;
        border-radius: 50%;
        background-color: rgba(52, 152, 219, 0.2);
        color: var(--primary-color);
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.3s ease;
        border: none;
        font-size: 20px;
      }
      
      .presentation-nav-button:hover {
        background-color: var(--primary-color);
        color: white;
        transform: scale(1.1);
      }
      
      .presentation-counter {
        font-size: 16px;
        color: var(--text-secondary);
        background-color: rgba(0, 0, 0, 0.05);
        padding: 5px 15px;
        border-radius: 50px;
      }
      
      /* Controles */
      .presentation-controls {
        position: absolute;
        top: 20px;
        right: 20px;
        display: flex;
        gap: 15px;
      }
      
      .presentation-control-button {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background-color: rgba(0, 0, 0, 0.1);
        color: var(--text-color);
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.3s ease;
        border: none;
      }
      
      .presentation-control-button:hover {
        background-color: var(--primary-color);
        color: white;
      }
      
      /* Animações */
      @keyframes fadeScale {
        from { opacity: 0; transform: scale(0.95); }
        to { opacity: 1; transform: scale(1); }
      }
      
      .slide-left {
        animation: slideLeft 0.5s ease;
      }
      
      .slide-right {
        animation: slideRight 0.5s ease;
      }
      
      @keyframes slideLeft {
        from { transform: translateX(50px); opacity: 0; }
        to { transform: translateX(0); opacity: 1; }
      }
      
      @keyframes slideRight {
        from { transform: translateX(-50px); opacity: 0; }
        to { transform: translateX(0); opacity: 1; }
      }
      
      /* Responsividade */
      @media (max-width: 768px) {
        .presentation-product {
          flex-direction: column;
          height: auto;
          max-height: 85vh;
          overflow-y: auto;
        }
        
        .presentation-image-container {
          width: 100%;
          height: 40vh;
        }
        
        .presentation-info {
          width: 100%;
          padding: 20px;
        }
        
        .presentation-name {
          font-size: 24px;
        }
        
        .presentation-category {
          font-size: 16px;
        }
        
        .presentation-price {
          font-size: 22px;
        }
      }
      
      /* Miniatura de produtos para navegação */
      .presentation-thumbnails {
        margin-top: 20px;
        width: 90%;
        max-width: 1200px;
        display: flex;
        gap: 10px;
        overflow-x: auto;
        padding: 10px;
        scrollbar-width: thin;
      }
      
      .presentation-thumbnail {
        width: 80px;
        height: 80px;
        border-radius: 10px;
        overflow: hidden;
        cursor: pointer;
        border: 3px solid transparent;
        transition: all 0.2s ease;
        flex-shrink: 0;
        background-color: var(--bg-secondary);
      }
      
      .presentation-thumbnail img {
        width: 100%;
        height: 100%;
        object-fit: contain;
      }
      
      .presentation-thumbnail.active {
        border-color: var(--primary-color);
        transform: scale(1.1);
      }
    `;
    document.head.appendChild(styleElement);
  }

  // Implementação da classe PresentationMode
  class PresentationMode {
    constructor() {
      this.active = false;
      this.currentIndex = 0;
      this.products = [];
      this.container = null;
      this.selectedCategory = null;
      
      // Adicionar estilos primeiro
      addPresentationStyles();
      
      // Inicializar
      this.initialize();
    }
    
    initialize() {
      // Adicionar botão de modo de apresentação
      this.createPresentationButton();
      
      // Criar container de apresentação (oculto inicialmente)
      this.createPresentationContainer();
      
      // Configurar atalhos de teclado
      document.addEventListener('keydown', this.handleKeyPress.bind(this));
    }
    
    createPresentationButton() {
      const presentationButton = document.createElement('div');
      presentationButton.className = 'presentation-mode-button';
      presentationButton.innerHTML = '<i class="fas fa-tv"></i>';
      presentationButton.title = 'Modo de apresentação';
      presentationButton.addEventListener('click', () => this.startPresentation());
      
      document.body.appendChild(presentationButton);
    }
    
    createPresentationContainer() {
      const container = document.createElement('div');
      container.className = 'presentation-container';
      
      container.innerHTML = `
        <div class="presentation-product">
          <div class="presentation-image-container">
            <img class="presentation-image" src="" alt="Produto">
          </div>
          <div class="presentation-info">
            <span class="presentation-sku"></span>
            <h2 class="presentation-name"></h2>
            <p class="presentation-category"></p>
            <div class="presentation-price"></div>
          </div>
          <div class="presentation-controls">
            <button class="presentation-control-button" id="presentation-close">
              <i class="fas fa-times"></i>
            </button>
            <button class="presentation-control-button" id="presentation-fullscreen">
              <i class="fas fa-expand"></i>
            </button>
          </div>
          <div class="presentation-navigation">
            <button class="presentation-nav-button" id="presentation-prev">
              <i class="fas fa-chevron-left"></i>
            </button>
            <div class="presentation-counter">0/0</div>
            <button class="presentation-nav-button" id="presentation-next">
              <i class="fas fa-chevron-right"></i>
            </button>
          </div>
        </div>
        <div class="presentation-thumbnails"></div>
      `;
      
      document.body.appendChild(container);
      this.container = container;
      
      // Configurar botões de controle
      container.querySelector('#presentation-close').addEventListener('click', () => this.stopPresentation());
      container.querySelector('#presentation-fullscreen').addEventListener('click', () => this.toggleFullScreen());
      container.querySelector('#presentation-prev').addEventListener('click', () => this.showPreviousProduct());
      container.querySelector('#presentation-next').addEventListener('click', () => this.showNextProduct());
    }
    
    startPresentation(categoryIndex = null) {
      // Coletar produtos para apresentação
      this.collectProducts(categoryIndex);
      
      if (this.products.length === 0) {
        if (typeof showNotification === 'function') {
          showNotification('Nenhum produto disponível para apresentação', 'error');
        } else {
          alert('Nenhum produto disponível para apresentação');
        }
        return;
      }
      
      // Exibir o container de apresentação
      this.container.classList.add('active');
      document.body.style.overflow = 'hidden';
      this.active = true;
      
      // Mostrar o primeiro produto
      this.currentIndex = 0;
      this.showCurrentProduct();
      
      // Atualizar miniaturas
      this.updateThumbnails();
      
      // Tentar entrar em modo tela cheia automaticamente
      this.toggleFullScreen();
    }
    
    stopPresentation() {
      this.container.classList.remove('active');
      document.body.style.overflow = '';
      this.active = false;
      
      // Sair do modo tela cheia se necessário
      if (document.fullscreenElement) {
        document.exitFullscreen().catch(err => console.error('Erro ao sair da tela cheia:', err));
      }
    }
    
    collectProducts(categoryIndex) {
      this.products = [];
      
      if (categoryIndex !== null) {
        // Coletar produtos de uma categoria específica
        const categoryElements = document.querySelectorAll('.category-section');
        if (categoryIndex >= 0 && categoryIndex < categoryElements.length) {
          this.selectedCategory = categoryElements[categoryIndex].querySelector('.category-title').textContent;
          const productElements = categoryElements[categoryIndex].querySelectorAll('.product');
          this.extractProductData(productElements);
        }
      } else {
        // Coletar todos os produtos visíveis
        this.selectedCategory = null;
        const productElements = document.querySelectorAll('.product');
        this.extractProductData(productElements);
      }
    }
    
    extractProductData(productElements) {
      productElements.forEach(product => {
        // Extrair dados do produto
        const sku = product.getAttribute('data-sku');
        const name = product.querySelector('.product-name')?.textContent || 'Produto sem nome';
        const category = product.querySelector('.product-category')?.textContent || '';
        let imgSrc = product.querySelector('img')?.src || '';
        
        // Usar imagem de alta resolução se disponível
        imgSrc = imgSrc.replace('300x300', '2500x2500');
        
        // Obter preço (se disponível no modo vendedor)
        let price = '';
        const priceInput = product.querySelector('.product-price-input');
        if (priceInput && priceInput.value) {
          price = `R$ ${priceInput.value}`;
        }
        
        this.products.push({ sku, name, category, imgSrc, price });
      });
    }
    
    showCurrentProduct(direction = null) {
      if (this.products.length === 0) return;
      
      const product = this.products[this.currentIndex];
      const productElement = this.container.querySelector('.presentation-product');
      
      // Adicionar animação de entrada
      productElement.className = 'presentation-product';
      void productElement.offsetWidth; // Forçar reflow para resetar a animação
      
      if (direction === 'prev') {
        productElement.classList.add('slide-right');
      } else if (direction === 'next') {
        productElement.classList.add('slide-left');
      } else {
        productElement.classList.add('fadeScale');
      }
      
      // Atualizar conteúdo do produto
      this.container.querySelector('.presentation-image').src = product.imgSrc;
      this.container.querySelector('.presentation-sku').textContent = `SKU: ${product.sku}`;
      this.container.querySelector('.presentation-name').textContent = product.name;
      this.container.querySelector('.presentation-category').textContent = product.category;
      
      // Exibir preço se disponível
      const priceElement = this.container.querySelector('.presentation-price');
      if (product.price) {
        priceElement.textContent = product.price;
        priceElement.style.display = 'block';
      } else {
        priceElement.style.display = 'none';
      }
      
      // Atualizar contador
      this.container.querySelector('.presentation-counter').textContent = `${this.currentIndex + 1}/${this.products.length}`;
      
      // Atualizar miniaturas
      this.updateActiveThumbnail();
    }
    
    showPreviousProduct() {
      if (this.currentIndex > 0) {
        this.currentIndex--;
        this.showCurrentProduct('prev');
      } else {
        // Voltar para o último produto em loop
        this.currentIndex = this.products.length - 1;
        this.showCurrentProduct('prev');
      }
    }
    
    showNextProduct() {
      if (this.currentIndex < this.products.length - 1) {
        this.currentIndex++;
        this.showCurrentProduct('next');
      } else {
        // Voltar para o primeiro produto em loop
        this.currentIndex = 0;
        this.showCurrentProduct('next');
      }
    }
    
    updateThumbnails() {
      if (this.products.length <= 1) return;
      
      const thumbnailsContainer = this.container.querySelector('.presentation-thumbnails');
      thumbnailsContainer.innerHTML = '';
      
      // Criar miniaturas para todos os produtos
      this.products.forEach((product, index) => {
        const thumbnail = document.createElement('div');
        thumbnail.className = 'presentation-thumbnail';
        if (index === this.currentIndex) {
          thumbnail.classList.add('active');
        }
        
        thumbnail.innerHTML = `<img src="${product.imgSrc}" alt="${product.name}">`;
        thumbnail.addEventListener('click', () => {
          this.currentIndex = index;
          this.showCurrentProduct();
        });
        
        thumbnailsContainer.appendChild(thumbnail);
      });
    }
    
    updateActiveThumbnail() {
      const thumbnails = this.container.querySelectorAll('.presentation-thumbnail');
      thumbnails.forEach((thumbnail, index) => {
        if (index === this.currentIndex) {
          thumbnail.classList.add('active');
        } else {
          thumbnail.classList.remove('active');
        }
      });
    }
    
    toggleFullScreen() {
      const presentationElement = this.container;
      
      if (!document.fullscreenElement) {
        // Entrar em modo tela cheia
        if (presentationElement.requestFullscreen) {
          presentationElement.requestFullscreen();
        } else if (presentationElement.mozRequestFullScreen) {
          presentationElement.mozRequestFullScreen();
        } else if (presentationElement.webkitRequestFullscreen) {
          presentationElement.webkitRequestFullscreen();
        } else if (presentationElement.msRequestFullscreen) {
          presentationElement.msRequestFullscreen();
        }
        
        // Atualizar ícone
        this.container.querySelector('#presentation-fullscreen i').className = 'fas fa-compress';
      } else {
        // Sair do modo tela cheia
        if (document.exitFullscreen) {
          document.exitFullscreen();
        } else if (document.mozCancelFullScreen) {
          document.mozCancelFullScreen();
        } else if (document.webkitExitFullscreen) {
          document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
          document.msExitFullscreen();
        }
        
        // Atualizar ícone
        this.container.querySelector('#presentation-fullscreen i').className = 'fas fa-expand';
      }
    }
    
    handleKeyPress(e) {
      if (!this.active) return;
      
      switch (e.key) {
        case 'ArrowLeft':
          this.showPreviousProduct();
          break;
        case 'ArrowRight':
          this.showNextProduct();
          break;
        case 'Escape':
          this.stopPresentation();
          break;
        case ' ': // Espaço
        case 'Enter':
          this.showNextProduct();
          break;
        case 'f':
          this.toggleFullScreen();
          break;
      }
    }
  }

  // Função para adicionar botões de apresentação nas categorias
  function addPresentationButtonsToCategories() {
    document.querySelectorAll('.category-title').forEach((titleElement, index) => {
      // Verificar se o botão já existe
      if (titleElement.querySelector('.category-presentation-btn')) return;
      
      // Criar botão de apresentação
      const presentationBtn = document.createElement('button');
      presentationBtn.className = 'category-presentation-btn';
      presentationBtn.innerHTML = '<i class="fas fa-play"></i>';
      presentationBtn.title = 'Apresentar produtos desta categoria';
      presentationBtn.style.cssText = `
        margin-left: 10px;
        background-color: var(--primary-color);
        color: white;
        border: none;
        border-radius: 50%;
        width: 28px;
        height: 28px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.2s;
      `;
      
      presentationBtn.addEventListener('mouseover', function() {
        this.style.transform = 'scale(1.1)';
      });
      
      presentationBtn.addEventListener('mouseout', function() {
        this.style.transform = 'scale(1)';
      });
      
      presentationBtn.addEventListener('click', function(e) {
        e.stopPropagation(); // Evitar interação com outros elementos
        window.startCategoryPresentation(index);
      });
      
      titleElement.appendChild(presentationBtn);
    });
  }

  // Inicializar o modo de apresentação e exportar para o escopo global
  window.addEventListener('load', function() {
    // Inicializar com segurança após carregamento completo
    setTimeout(function() {
      // Criar a instância do modo de apresentação
      window.presentationMode = new PresentationMode();
      
      // Adicionar botões de apresentação às categorias
      addPresentationButtonsToCategories();
      
      // Configurar observador para novas categorias
      const observer = new MutationObserver(function(mutations) {
        mutations.forEach(function(mutation) {
          if (mutation.type === 'childList' && mutation.addedNodes.length) {
            setTimeout(addPresentationButtonsToCategories, 300);
          }
        });
      });
      
      const productList = document.getElementById('product-list');
      if (productList) {
        observer.observe(productList, { childList: true, subtree: true });
      }
    }, 1500);
  });

  // Adicionar função para iniciar apresentação para uma categoria específica
  window.startCategoryPresentation = function(categoryIndex) {
    if (window.presentationMode) {
      window.presentationMode.startPresentation(categoryIndex);
    }
  };
})();



    </script>
	
	<script>
	// Implementação completa do modo tela cheia e apresentação para o catálogo
// Adicionar este script no final do arquivo HTML, antes do fechamento da tag </body>

// Função auto-executável para evitar conflitos de variáveis
(function() {
  // ===== 1. ESTILOS CSS PARA O MODO TELA CHEIA =====
  function addFullscreenStyles() {
    const styleElement = document.createElement('style');
    styleElement.textContent = `
      /* Estilos gerais para modo tela cheia */
      .fullscreen-element {
        background-color: var(--bg-primary);
        width: 100% !important;
        height: 100% !important;
        margin: 0 !important;
        padding: 0 !important;
        overflow: auto !important;
      }
      
      /* Barra de controle flutuante que aparece em tela cheia */
      .fullscreen-controls {
        position: fixed;
        bottom: 20px;
        right: 20px;
        background-color: var(--bg-secondary);
        border-radius: 10px;
        padding: 10px;
        box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        display: flex;
        gap: 15px;
        z-index: 9999;
        transition: opacity 0.3s;
        opacity: 0.4;
      }
      
      .fullscreen-controls:hover {
        opacity: 1;
      }
      
      .fullscreen-btn {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background-color: var(--primary-color);
        color: white;
        border: none;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.2s;
        font-size: 18px;
      }
      
      .fullscreen-btn:hover {
        transform: scale(1.1);
        background-color: var(--secondary-color);
      }
      
      /* Botão para ativar tela cheia */
      .toggle-fullscreen-btn {
        position: fixed;
        right: 20px;
        bottom: 140px;
        width: 50px;
        height: 50px;
        border-radius: 50%;
        background-color: var(--primary-color);
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 3px 10px rgba(0,0,0,0.2);
        cursor: pointer;
        z-index: 100;
        transition: all 0.3s;
      }
      
      .toggle-fullscreen-btn:hover {
        transform: scale(1.1);
        background-color: var(--secondary-color);
      }
      
      /* Ajustes específicos para o catálogo em tela cheia */
      .fullscreen-element .header-controls,
      .fullscreen-element .vendor-controls {
        width: auto;
        max-width: 100%;
      }
      
      .fullscreen-element .filters {
        position: sticky;
        top: 0;
        z-index: 90;
      }
      
      .fullscreen-element .products {
        grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
      }
      
      .fullscreen-element .product {
        transition: transform 0.3s;
      }
      
      .fullscreen-element .product:hover {
        transform: translateY(-10px) scale(1.03);
        z-index: 10;
      }
      
      .fullscreen-element .product-img-container {
        height: 200px;
      }
      
      .fullscreen-element header {
        position: relative;
        transform: none !important;
      }
      
      /* Estilos para o menu de presets de zoom */
      .zoom-preset-option {
        padding: 8px 15px;
        cursor: pointer;
        border-radius: 4px;
        transition: background-color 0.2s;
      }
      
      .zoom-preset-option:hover {
        background-color: rgba(52, 152, 219, 0.1);
      }
      
      .zoom-preset-option.active {
        background-color: var(--primary-color);
        color: white;
      }
      
      /* Estilo do indicador de zoom */
      #zoom-level {
        cursor: pointer;
        transition: background-color 0.2s;
      }
      
      #zoom-level:hover {
        background-color: rgba(255, 255, 255, 0.3);
      }

      /* Modo de apresentação de slides */
      .presentation-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: var(--bg-primary);
        z-index: 10000;
        display: none;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        transition: opacity 0.5s;
        opacity: 0;
      }
      
      .presentation-container.active {
        display: flex;
        opacity: 1;
      }
      
      .presentation-slide {
        width: 90%;
        max-width: 1200px;
        height: 80%;
        background-color: var(--bg-secondary);
        box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        border-radius: 20px;
        padding: 30px;
        display: flex;
        position: relative;
        animation: fadeIn 0.5s;
      }
      
      .presentation-image {
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
      }
      
      .presentation-image img {
        max-width: 100%;
        max-height: 100%;
        object-fit: contain;
        transition: transform 0.5s;
      }
      
      .presentation-image img:hover {
        transform: scale(1.05);
      }
      
      .presentation-info {
        flex: 1;
        padding: 0 30px;
        display: flex;
        flex-direction: column;
        justify-content: center;
      }
      
      .presentation-sku {
        font-size: 20px;
        background-color: rgba(52, 152, 219, 0.1);
        color: var(--primary-color);
        display: inline-block;
        padding: 5px 15px;
        border-radius: 50px;
        margin-bottom: 20px;
      }
      
      .presentation-name {
        font-size: 36px;
        font-weight: 600;
        margin-bottom: 20px;
      }
      
      .presentation-category {
        font-size: 24px;
        color: var(--text-secondary);
        margin-bottom: 20px;
      }
      
      .presentation-price {
        font-size: 30px;
        color: var(--accent-color);
        font-weight: 600;
        margin-top: 30px;
      }
      
      .presentation-navigation {
        position: absolute;
        bottom: 20px;
        left: 0;
        width: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 30px;
      }
      
      .presentation-nav-btn {
        width: 60px;
        height: 60px;
        border-radius: 50%;
        background-color: var(--primary-color);
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        font-size: 24px;
        transition: all 0.3s;
        border: none;
      }
      
      .presentation-nav-btn:hover {
        transform: scale(1.1);
        background-color: var(--secondary-color);
      }
      
      .presentation-counter {
        font-size: 18px;
        background-color: rgba(52, 152, 219, 0.1);
        padding: 5px 20px;
        border-radius: 50px;
      }
      
      .presentation-close {
        position: absolute;
        top: 20px;
        right: 20px;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background-color: rgba(0,0,0,0.1);
        color: var(--text-color);
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.3s;
        z-index: 1;
      }
      
      .presentation-close:hover {
        background-color: var(--error-color);
        color: white;
      }
      
      /* Thumbnails para navegação entre produtos */
      .presentation-thumbnails {
        margin-top: 20px;
        width: 90%;
        max-width: 1200px;
        display: flex;
        gap: 10px;
        overflow-x: auto;
        padding: 10px;
      }
      
      .presentation-thumb {
        width: 80px;
        height: 80px;
        border-radius: 10px;
        overflow: hidden;
        cursor: pointer;
        border: 3px solid transparent;
        transition: all 0.3s;
      }
      
      .presentation-thumb img {
        width: 100%;
        height: 100%;
        object-fit: contain;
      }
      
      .presentation-thumb.active {
        border-color: var(--primary-color);
        transform: scale(1.1);
      }
      
      /* Responsividade do modo apresentação */
      @media (max-width: 992px) {
        .presentation-slide {
          flex-direction: column;
          overflow-y: auto;
        }
        
        .presentation-image {
          height: 50%;
        }
        
        .presentation-info {
          padding: 20px 0;
        }
        
        .presentation-name {
          font-size: 28px;
        }
        
        .presentation-category {
          font-size: 18px;
        }
        
        .presentation-price {
          font-size: 24px;
        }
      }
      
      /* Animações */
      @keyframes fadeIn {
        from { opacity: 0; transform: scale(0.95); }
        to { opacity: 1; transform: scale(1); }
      }
      
      @keyframes slideLeft {
        from { transform: translateX(50px); opacity: 0; }
        to { transform: translateX(0); opacity: 1; }
      }
      
      @keyframes slideRight {
        from { transform: translateX(-50px); opacity: 0; }
        to { transform: translateX(0); opacity: 1; }
      }
      
      .slide-left {
        animation: slideLeft 0.5s;
      }
      
      .slide-right {
        animation: slideRight 0.5s;
      }
      
      /* Botão de apresentação para categorias */
      .category-presentation-btn {
        margin-left: 10px;
        background-color: var(--primary-color);
        color: white;
        border: none;
        border-radius: 50%;
        width: 28px;
        height: 28px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.2s;
      }
      
      .category-presentation-btn:hover {
        transform: scale(1.1) !important;
      }
    `;
    document.head.appendChild(styleElement);
  }

  // ===== 2. FUNCIONALIDADE DE TELA CHEIA BÁSICA =====
  class FullscreenManager {
    constructor() {
      // Adicionar estilos CSS
      addFullscreenStyles();
      
      // Estado
      this.isFullscreen = false;
      this.targetElement = document.body;
      this.zoomLevel = 103; // Valor percentual de zoom (padrão: 100%)
      this.minZoom = 25;    // Zoom mínimo: 25%
      this.maxZoom = 500;   // Zoom máximo: 500%
      this.zoomStep = 25;   // Incrementos de zoom
      
      // Criar botão de tela cheia
      this.createFullscreenButton();
      
      // Monitorar eventos de tela cheia
      this.setupFullscreenEventListeners();
    }
    
    createFullscreenButton() {
      // Botão principal de tela cheia
      const fsButton = document.createElement('div');
      fsButton.className = 'toggle-fullscreen-btn';
      fsButton.innerHTML = '<i class="fas fa-expand"></i>';
      fsButton.title = 'Ativar/Desativar modo tela cheia';
      fsButton.addEventListener('click', () => this.toggleFullscreen());
      document.body.appendChild(fsButton);
      this.fsButton = fsButton;
      
      // Barra de controles (visível apenas em tela cheia)
      const controls = document.createElement('div');
      controls.className = 'fullscreen-controls';
      controls.style.display = 'none';
      controls.innerHTML = `
        <button class="fullscreen-btn" id="zoom-out-btn" title="Reduzir visualização">
          <i class="fas fa-search-minus"></i>
        </button>
        <span id="zoom-level" style="background-color: rgba(255,255,255,0.2); color: var(--text-color); padding: 5px 10px; border-radius: 4px; font-size: 14px; min-width: 70px; text-align: center;">100%</span>
        <button class="fullscreen-btn" id="zoom-in-btn" title="Ampliar visualização">
          <i class="fas fa-search-plus"></i>
        </button>
        <button class="fullscreen-btn" id="zoom-reset-btn" title="Restaurar zoom padrão (100%)">
          <i class="fas fa-sync-alt"></i>
        </button>
        <button class="fullscreen-btn" id="presentation-btn" title="Modo apresentação">
          <i class="fas fa-tv"></i>
        </button>
        <button class="fullscreen-btn" id="exit-fullscreen-btn" title="Sair da tela cheia">
          <i class="fas fa-compress"></i>
        </button>
      `;
      document.body.appendChild(controls);
      this.controls = controls;
      
      // Configurar eventos dos botões de controle
      document.getElementById('zoom-out-btn').addEventListener('click', () => this.decreaseZoom());
      document.getElementById('zoom-in-btn').addEventListener('click', () => this.increaseZoom());
      document.getElementById('zoom-reset-btn').addEventListener('click', () => this.resetZoom());
      document.getElementById('exit-fullscreen-btn').addEventListener('click', () => this.exitFullscreen());
      document.getElementById('presentation-btn').addEventListener('click', () => this.startPresentation());
      
      // Adicionar evento de roda do mouse para zoom
      this.targetElement.addEventListener('wheel', (e) => {
        if (this.isFullscreen && e.ctrlKey) {
          e.preventDefault();
          if (e.deltaY < 0) {
            this.increaseZoom();
          } else {
            this.decreaseZoom();
          }
        }
      }, { passive: false });
    }
    
    setupFullscreenEventListeners() {
      // Monitorar eventos de tela cheia
      document.addEventListener('fullscreenchange', () => this.handleFullscreenChange());
      document.addEventListener('webkitfullscreenchange', () => this.handleFullscreenChange());
      document.addEventListener('mozfullscreenchange', () => this.handleFullscreenChange());
      document.addEventListener('MSFullscreenChange', () => this.handleFullscreenChange());
      
      // Teclas de atalho
      document.addEventListener('keydown', (e) => {
        if (this.isFullscreen) {
          if (e.key === 'Escape') {
            this.exitFullscreen();
          } else if (e.key === 'f' || e.key === 'F') {
            this.toggleFullscreen();
          } else if ((e.key === '=' || e.key === '+') && (e.ctrlKey || e.metaKey)) {
            e.preventDefault(); // Prevenir zoom do navegador
            this.increaseZoom();
          } else if ((e.key === '-' || e.key === '_') && (e.ctrlKey || e.metaKey)) {
            e.preventDefault(); // Prevenir zoom do navegador
            this.decreaseZoom();
          } else if (e.key === '0' && (e.ctrlKey || e.metaKey)) {
            e.preventDefault(); // Prevenir zoom padrão do navegador
            this.resetZoom();
          } else if (e.key === 'p' || e.key === 'P') {
            this.startPresentation();
          } else if (e.key >= '1' && e.key <= '9' && (e.ctrlKey || e.metaKey || e.altKey)) {
            // Presets de zoom com teclas numéricas + modificador
            e.preventDefault();
            const presets = {
              '1': 25,    // 25%
              '2': 50,    // 50%
              '3': 75,    // 75%
              '4': 100,   // 100% (padrão)
              '5': 150,   // 150%
              '6': 200,   // 200%
              '7': 300,   // 300%
              '8': 400,   // 400%
              '9': 500    // 500%
            };
            if (presets[e.key]) {
              this.setZoom(presets[e.key]);
            }
          }
        }
      });
    }
    
    toggleFullscreen() {
      if (this.isFullscreen) {
        this.exitFullscreen();
      } else {
        this.enterFullscreen();
      }
    }
    
    enterFullscreen() {
      const element = this.targetElement;
      
      try {
        if (element.requestFullscreen) {
          element.requestFullscreen();
        } else if (element.mozRequestFullScreen) { // Firefox
          element.mozRequestFullScreen();
        } else if (element.webkitRequestFullscreen) { // Chrome, Safari & Opera
          element.webkitRequestFullscreen();
        } else if (element.msRequestFullscreen) { // IE/Edge
          element.msRequestFullscreen();
        } else {
          // Fallback para navegadores que não suportam a API Fullscreen
          this.applyFullscreenStyles();
          this.isFullscreen = true;
          this.updateFullscreenUI();
        }
      } catch (error) {
        console.error('Erro ao entrar no modo tela cheia:', error);
        this.applyFullscreenStyles();
        this.isFullscreen = true;
        this.updateFullscreenUI();
      }
    }
    
    exitFullscreen() {
      try {
        if (document.exitFullscreen) {
          document.exitFullscreen();
        } else if (document.mozCancelFullScreen) { // Firefox
          document.mozCancelFullScreen();
        } else if (document.webkitExitFullscreen) { // Chrome, Safari & Opera
          document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) { // IE/Edge
          document.msExitFullscreen();
        } else {
          // Fallback
          this.removeFullscreenStyles();
          this.isFullscreen = false;
          this.updateFullscreenUI();
        }
      } catch (error) {
        console.error('Erro ao sair do modo tela cheia:', error);
        this.removeFullscreenStyles();
        this.isFullscreen = false;
        this.updateFullscreenUI();
      }
    }
    
    handleFullscreenChange() {
      // Verificar se estamos em tela cheia
      this.isFullscreen = Boolean(
        document.fullscreenElement || 
        document.webkitFullscreenElement || 
        document.mozFullScreenElement ||
        document.msFullscreenElement
      );
      
      // Atualizar a interface de acordo
      if (this.isFullscreen) {
        this.applyFullscreenStyles();
      } else {
        this.removeFullscreenStyles();
      }
      
      this.updateFullscreenUI();
    }
    
    applyFullscreenStyles() {
      // Adicionar classes e estilos de tela cheia
      this.targetElement.classList.add('fullscreen-element');
      
      // Adicionar menu de presets de zoom
      this.addZoomPresetsMenu();
      
      // Aplicar zoom atual
      this.applyZoom();
      
      // Salvar o estado da header para restauração posterior
      if (!this.headerOriginalState) {
        const header = document.querySelector('header');
        if (header) {
          this.headerOriginalState = {
            position: header.style.position,
            top: header.style.top,
            transform: header.style.transform
          };
        }
      }
      
      // Otimizar header em tela cheia
      const header = document.querySelector('header');
      if (header) {
        // Remover posicionamento sticky
        header.style.position = 'relative';
        header.style.top = '0';
        header.style.transform = 'none';
        header.classList.remove('hide');
      }
    }
    
    removeFullscreenStyles() {
      // Remover classes e estilos de tela cheia
      this.targetElement.classList.remove('fullscreen-element');
      
      // Remover menu de presets se existir
      const presetsMenu = document.getElementById('zoom-presets-menu');
      if (presetsMenu) {
        presetsMenu.remove();
      }
      
      // Remover qualquer transformação de zoom
      const productContainer = document.querySelector('#product-list');
      if (productContainer) {
        productContainer.style.removeProperty('transform');
        productContainer.style.removeProperty('transform-origin');
        productContainer.style.removeProperty('height');
      }
      
      // Restaurar estado original da header
      if (this.headerOriginalState) {
        const header = document.querySelector('header');
        if (header) {
          header.style.position = this.headerOriginalState.position;
          header.style.top = this.headerOriginalState.top;
          header.style.transform = this.headerOriginalState.transform;
        }
      }
    }
    
    addZoomPresetsMenu() {
      // Criar menu dropdown para presets de zoom
      let presetsMenu = document.getElementById('zoom-presets-menu');
      
      // Se já existe, remover para recriar
      if (presetsMenu) {
        presetsMenu.remove();
      }
      
      // Criar elemento para o menu de presets
      presetsMenu = document.createElement('div');
      presetsMenu.id = 'zoom-presets-menu';
      presetsMenu.style.cssText = `
        position: absolute;
        top: calc(100% + 10px);
        left: 50%;
        transform: translateX(-50%);
        background-color: var(--bg-secondary);
        border-radius: 8px;
        box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        padding: 10px;
        display: none;
        flex-direction: column;
        gap: 5px;
        z-index: 9999;
        min-width: 120px;
      `;
      
      // Adicionar opções de zoom
      const zoomOptions = [25, 50, 75, 100, 125, 150, 200, 300, 400, 500];
      zoomOptions.forEach(zoom => {
        const option = document.createElement('div');
        option.className = 'zoom-preset-option';
        option.textContent = `${zoom}%`;
        option.style.cssText = `
          padding: 8px 15px;
          cursor: pointer;
          border-radius: 4px;
          transition: background-color 0.2s;
          ${this.zoomLevel === zoom ? 'background-color: var(--primary-color); color: white;' : ''}
        `;
        option.addEventListener('mouseover', () => {
          if (this.zoomLevel !== zoom) {
            option.style.backgroundColor = 'rgba(52, 152, 219, 0.1)';
          }
        });
        option.addEventListener('mouseout', () => {
          if (this.zoomLevel !== zoom) {
            option.style.backgroundColor = '';
          }
        });
        option.addEventListener('click', () => {
          this.setZoom(zoom);
          presetsMenu.style.display = 'none';
        });
        presetsMenu.appendChild(option);
      });
      
      // Adicionar ao documento
      this.controls.appendChild(presetsMenu);
      
      // Adicionar evento para mostrar/ocultar o menu
      const zoomLevelIndicator = document.getElementById('zoom-level');
      if (zoomLevelIndicator) {
        zoomLevelIndicator.style.cursor = 'pointer';
        zoomLevelIndicator.title = 'Clique para selecionar um nível de zoom';
        
        zoomLevelIndicator.addEventListener('click', () => {
          if (presetsMenu.style.display === 'flex') {
            presetsMenu.style.display = 'none';
          } else {
            presetsMenu.style.display = 'flex';
          }
        });
        
        // Fechar ao clicar fora
        document.addEventListener('click', (e) => {
          if (!zoomLevelIndicator.contains(e.target) && !presetsMenu.contains(e.target)) {
            presetsMenu.style.display = 'none';
          }
        });
      }
    }
    
    updateFullscreenUI() {
      // Atualizar a aparência do botão
      if (this.isFullscreen) {
        this.fsButton.innerHTML = '<i class="fas fa-compress"></i>';
        this.controls.style.display = 'flex';
      } else {
        this.fsButton.innerHTML = '<i class="fas fa-expand"></i>';
        this.controls.style.display = 'none';
      }
    }
    
    increaseZoom() {
      // Aumentar zoom pelo incremento definido
      this.zoomLevel = Math.min(this.maxZoom, this.zoomLevel + this.zoomStep);
      this.applyZoom();
    }
    
    decreaseZoom() {
      // Diminuir zoom pelo incremento definido
      this.zoomLevel = Math.max(this.minZoom, this.zoomLevel - this.zoomStep);
      this.applyZoom();
    }
    
    resetZoom() {
      // Restaurar para o zoom padrão (103%)
      this.zoomLevel = 103;
      this.applyZoom();
    }
    
    setZoom(level) {
      // Definir um nível específico de zoom
      this.zoomLevel = Math.max(this.minZoom, Math.min(this.maxZoom, level));
      this.applyZoom();
    }
    
    applyZoom() {
      if (!this.isFullscreen) return;
      
      // Encontrar o elemento que contém os produtos
      const productContainer = document.querySelector('#product-list');
      if (!productContainer) return;
      
      // Remover qualquer estilo de zoom anterior
      productContainer.style.removeProperty('transform');
      productContainer.style.removeProperty('transform-origin');
      
      // Aplicar o estilo de zoom
      if (this.zoomLevel !== 100) {
        const scale = this.zoomLevel / 100;
        
        // Definir estilos para o container de produtos
        productContainer.style.transform = `scale(${scale})`;
        productContainer.style.transformOrigin = 'top center';
        
        // Ajustar espaço para o conteúdo escalado
        if (this.zoomLevel > 100) {
          // Quando ampliado, precisamos de mais espaço
          const height = (scale * 100) + '%';
          productContainer.style.height = height;
        }
      }
      
      // Atualizar o indicador de zoom na interface
      const zoomIndicator = document.getElementById('zoom-level');
      if (zoomIndicator) {
        zoomIndicator.textContent = `${this.zoomLevel}%`;
      }
      
      // Mostrar notificação, se disponível
      if (typeof showNotification === 'function') {
        showNotification(`Zoom: ${this.zoomLevel}%`, 'success');
      }
    }
    
    startPresentation() {
      if (typeof presentationManager !== 'undefined') {
        presentationManager.startPresentation();
      } else {
        console.error('Gerenciador de apresentação não está disponível');
        if (typeof showNotification === 'function') {
          showNotification('Não foi possível iniciar o modo de apresentação', 'error');
        }
      }
    }
  }

  // ===== 3. FUNCIONALIDADE DE APRESENTAÇÃO DE PRODUTOS =====
  class PresentationManager {
    constructor() {
      this.currentIndex = 0;
      this.products = [];
      this.isActive = false;
      
      // Criar container de apresentação
      this.createPresentationContainer();
    }
    
    createPresentationContainer() {
      const container = document.createElement('div');
      container.className = 'presentation-container';
      container.innerHTML = `
        <div class="presentation-slide">
          <div class="presentation-image">
            <img src="" alt="Produto">
          </div>
          <div class="presentation-info">
            <div class="presentation-sku"></div>
            <h2 class="presentation-name"></h2>
            <div class="presentation-category"></div>
            <div class="presentation-price"></div>
          </div>
          <div class="presentation-close">
            <i class="fas fa-times"></i>
          </div>
          <div class="presentation-navigation">
            <button class="presentation-nav-btn prev-btn">
              <i class="fas fa-chevron-left"></i>
            </button>
            <div class="presentation-counter">1/1</div>
            <button class="presentation-nav-btn next-btn">
              <i class="fas fa-chevron-right"></i>
            </button>
          </div>
        </div>
        <div class="presentation-thumbnails"></div>
      `;
      
      document.body.appendChild(container);
      this.container = container;
      
      // Configurar eventos
      container.querySelector('.presentation-close').addEventListener('click', () => this.stopPresentation());
      container.querySelector('.prev-btn').addEventListener('click', () => this.showPreviousProduct());
      container.querySelector('.next-btn').addEventListener('click', () => this.showNextProduct());
      
      // Adicionar evento de teclado
      document.addEventListener('keydown', (e) => {
        if (!this.isActive) return;
        
        if (e.key === 'ArrowRight' || e.key === ' ') {
          this.showNextProduct();
          e.preventDefault();
        } else if (e.key === 'ArrowLeft') {
          this.showPreviousProduct();
          e.preventDefault();
        } else if (e.key === 'Escape') {
          this.stopPresentation();
          e.preventDefault();
        }
      });
    }
    
    startPresentation(categoryIndex = null) {
      // Coletar produtos para apresentação
      this.collectProducts(categoryIndex);
      
      if (this.products.length === 0) {
        if (typeof showNotification === 'function') {
          showNotification('Nenhum produto disponível para apresentação', 'error');
        } else {
          alert('Nenhum produto disponível para apresentação');
        }
        return;
      }
      
      // Mostrar o container
      this.isActive = true;
      this.container.classList.add('active');
      document.body.style.overflow = 'hidden';
      
      // Mostrar o primeiro produto
      this.currentIndex = 0;
      this.updateProductDisplay();
      
      // Criar miniaturas para navegação
      this.createThumbnails();
    }
    
    stopPresentation() {
      this.isActive = false;
      this.container.classList.remove('active');
      document.body.style.overflow = '';
    }
    
    collectProducts(categoryIndex = null) {
      this.products = [];
      
      if (categoryIndex !== null) {
        // Produtos de uma categoria específica
        const categories = document.querySelectorAll('.category-section');
        if (categories.length > categoryIndex) {
          const products = categories[categoryIndex].querySelectorAll('.product');
          this.addProductsToCollection(products);
        }
      } else {
        // Todos os produtos visíveis
        const products = document.querySelectorAll('.product');
        this.addProductsToCollection(products);
      }
    }
    
    addProductsToCollection(productElements) {
      productElements.forEach(product => {
        const sku = product.getAttribute('data-sku') || '';
        const nameElement = product.querySelector('.product-name');
        const name = nameElement ? nameElement.textContent : '';
        
        const categoryElement = product.querySelector('.product-category');
        const category = categoryElement ? categoryElement.textContent : '';
        
        const imgElement = product.querySelector('img');
        // Usar versão de alta resolução da imagem se disponível
        let imgSrc = imgElement ? imgElement.src.replace('300x300', '2500x2500') : '';
        
        // Tentar obter o preço (se estiver no modo vendedor)
        let price = '';
        const priceInput = product.querySelector('.product-price-input');
        if (priceInput && priceInput.value) {
          price = `R$ ${priceInput.value}`;
        }
        
        this.products.push({
          sku,
          name,
          category,
          imgSrc,
          price
        });
      });
    }
    
    updateProductDisplay(direction = null) {
      if (this.products.length === 0) return;
      
      const product = this.products[this.currentIndex];
      const slide = this.container.querySelector('.presentation-slide');
      
      // Limpar classes de animação anteriores
      slide.className = 'presentation-slide';
      void slide.offsetWidth; // Forçar reflow para reiniciar animação
      
      // Adicionar classe de animação baseada na direção
      if (direction === 'next') {
        slide.classList.add('slide-left');
      } else if (direction === 'prev') {
        slide.classList.add('slide-right');
      }
      
      // Atualizar informações do produto
      this.container.querySelector('.presentation-image img').src = product.imgSrc;
      this.container.querySelector('.presentation-sku').textContent = `SKU: ${product.sku}`;
      this.container.querySelector('.presentation-name').textContent = product.name;
      this.container.querySelector('.presentation-category').textContent = product.category;
      
      const priceElement = this.container.querySelector('.presentation-price');
      if (product.price) {
        priceElement.textContent = product.price;
        priceElement.style.display = 'block';
      } else {
        priceElement.style.display = 'none';
      }
      
      // Atualizar contador
      this.container.querySelector('.presentation-counter').textContent = 
        `${this.currentIndex + 1}/${this.products.length}`;
      
      // Atualizar miniaturas
      this.updateActiveThumbnail();
    }
    
    showNextProduct() {
      if (this.currentIndex < this.products.length - 1) {
        this.currentIndex++;
      } else {
        this.currentIndex = 0; // Voltar ao início
      }
      this.updateProductDisplay('next');
    }
    
    showPreviousProduct() {
      if (this.currentIndex > 0) {
        this.currentIndex--;
      } else {
        this.currentIndex = this.products.length - 1; // Ir para o último
      }
      this.updateProductDisplay('prev');
    }
    
    createThumbnails() {
      const container = this.container.querySelector('.presentation-thumbnails');
      container.innerHTML = '';
      
      this.products.forEach((product, index) => {
        const thumb = document.createElement('div');
        thumb.className = 'presentation-thumb';
        if (index === this.currentIndex) {
          thumb.classList.add('active');
        }
        
        thumb.innerHTML = `<img src="${product.imgSrc}" alt="${product.name}">`;
        thumb.addEventListener('click', () => {
          const direction = index > this.currentIndex ? 'next' : 'prev';
          this.currentIndex = index;
          this.updateProductDisplay(direction);
        });
        
        container.appendChild(thumb);
      });
    }
    
    updateActiveThumbnail() {
      const thumbs = this.container.querySelectorAll('.presentation-thumb');
      thumbs.forEach((thumb, index) => {
        if (index === this.currentIndex) {
          thumb.classList.add('active');
        } else {
          thumb.classList.remove('active');
        }
      });
    }
    
    goToProduct(index) {
      if (index >= 0 && index < this.products.length) {
        const direction = index > this.currentIndex ? 'next' : 'prev';
        this.currentIndex = index;
        this.updateProductDisplay(direction);
      }
    }
  }

  // ===== 4. ADICIONAR BOTÃO DE APRESENTAÇÃO ÀS CATEGORIAS =====
  function addPresentationButtonsToCategories() {
    document.querySelectorAll('.category-title').forEach((title, index) => {
      // Verificar se o botão já existe
      if (title.querySelector('.category-presentation-btn')) return;
      
      const presentationBtn = document.createElement('button');
      presentationBtn.className = 'category-presentation-btn';
      presentationBtn.innerHTML = '<i class="fas fa-play"></i>';
      presentationBtn.title = 'Apresentar produtos desta categoria';
      
      presentationBtn.addEventListener('click', (e) => {
        e.stopPropagation(); // Evitar conflitos com outros eventos
        if (window.presentationManager) {
          window.presentationManager.startPresentation(index);
        }
      });
      
      title.appendChild(presentationBtn);
    });
  }

  // ===== 5. INICIALIZAÇÃO =====
  function init() {
    // Criar instâncias dos gerenciadores
    window.fullscreenManager = new FullscreenManager();
    window.presentationManager = new PresentationManager();
    
    // Adicionar botões de apresentação às categorias
    addPresentationButtonsToCategories();
    
    // Configurar observador para novas categorias
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.type === 'childList' && mutation.addedNodes.length) {
          setTimeout(addPresentationButtonsToCategories, 500);
        }
      });
    });
    
    const productList = document.getElementById('product-list');
    if (productList) {
      observer.observe(productList, { childList: true, subtree: true });
    }
    
    // Log de inicialização bem-sucedida
    console.log('Modo tela cheia e apresentação inicializados com sucesso');
  }

  // Inicializar após o carregamento completo da página
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    // Se o DOM já estiver pronto, inicializar diretamente
    setTimeout(init, 500);
  }
})();
	</script>
	<script>
	// Script para substituir completamente o modal de visualização de produto
// Este script deve ser adicionado diretamente na página HTML

(function() {
  // Executar imediatamente após o carregamento do script
  console.log("Inicializando substituição do modal de produto...");
  
  // 1. Primeiro, vamos garantir que o script seja executado após o carregamento da página
  function inicializar() {
    // Substituir a função openImageModal existente
    substituirFuncaoModal();
    
    // Adicionar estilos diretamente
    adicionarEstilos();
    
    // Adicionar eventos de clique a todos os produtos
    adicionarEventosClique();
    
    console.log("Substituição do modal de produto concluída!");
  }
  
  // 2. Substituir completamente a função openImageModal
  function substituirFuncaoModal() {
    // Salvar referência à função original (se existir)
    const funcaoOriginal = window.openImageModal;
    
    // Criar nossa nova função
    window.openImageModal = function(imgSrc, sku, name) {
      console.log("Nova função de modal ativada:", imgSrc, sku, name);
      
      // Se a função original existir e não conseguirmos mostrar nosso modal, tentar a original como fallback
      let modalCriado = criarEMostrarNovoModal(imgSrc, sku, name);
      
      if (!modalCriado && typeof funcaoOriginal === 'function') {
        console.log("Fallback para função original de modal");
        return funcaoOriginal(imgSrc, sku, name);
      }
    };
  }
  
  // 3. Criar e mostrar nosso novo modal aprimorado
  function criarEMostrarNovoModal(imgSrc, sku, name) {
    try {
      // Remover qualquer modal existente primeiro
      const modalExistente = document.getElementById('novoImageModal');
      if (modalExistente) {
        document.body.removeChild(modalExistente);
      }
      
      // Garantir que a URL da imagem seja de alta resolução
      let imagemHD = imgSrc;
      if (imgSrc && imgSrc.includes('300x300')) {
        imagemHD = imgSrc.replace('300x300', '2500x2500');
      }
      
      // Criar o elemento do modal
      const modal = document.createElement('div');
      modal.id = 'novoImageModal';
      modal.className = 'novo-modal';
      
      // HTML interno do modal
      modal.innerHTML = `
        <div class="novo-modal-content">
          <span class="novo-modal-close">&times;</span>
          <div class="novo-modal-info">
            <h3 class="produto-nome">${name || 'Nome do Produto'}</h3>
            <p class="produto-sku">Código: ${sku}</p>
          </div>
          <div class="novo-modal-body">
            <div class="novo-modal-image-container">
              <img src="${imagemHD}" alt="${name}" class="novo-modal-image">
              <div class="zoom-controls">
                <button class="zoom-btn zoom-out" title="Diminuir"><i class="fas fa-search-minus"></i></button>
                <button class="zoom-btn zoom-reset" title="Restaurar"><i class="fas fa-sync-alt"></i></button>
                <button class="zoom-btn zoom-in" title="Aumentar"><i class="fas fa-search-plus"></i></button>
              </div>
            </div>
          </div>
        </div>
      `;
      
      // Adicionar o modal ao corpo do documento
      document.body.appendChild(modal);
      
      // Configurar eventos
      const closeBtn = modal.querySelector('.novo-modal-close');
      closeBtn.addEventListener('click', function() {
        document.body.removeChild(modal);
      });
      
      // Fechar ao clicar fora do conteúdo
      modal.addEventListener('click', function(e) {
        if (e.target === modal) {
          document.body.removeChild(modal);
        }
      });
      
      // Adicionar funcionalidade de zoom
      const imagem = modal.querySelector('.novo-modal-image');
      const zoomOutBtn = modal.querySelector('.zoom-out');
      const zoomResetBtn = modal.querySelector('.zoom-reset');
      const zoomInBtn = modal.querySelector('.zoom-in');
      
      // Estado do zoom
      let zoomLevel = 1;
      const maxZoom = 3;
      const minZoom = 1;
      
      // Função para aplicar zoom
      function aplicarZoom() {
        imagem.style.transform = `scale(${zoomLevel})`;
        
        // Ajustar cursor com base no nível de zoom
        if (zoomLevel > 1) {
          imagem.style.cursor = 'move';
        } else {
          imagem.style.cursor = 'pointer';
          imagem.style.transformOrigin = 'center center';
        }
      }
      
      // Configurar eventos de zoom
      zoomOutBtn.addEventListener('click', function() {
        zoomLevel = Math.max(minZoom, zoomLevel - 0.5);
        aplicarZoom();
      });
      
      zoomResetBtn.addEventListener('click', function() {
        zoomLevel = 1;
        aplicarZoom();
      });
      
      zoomInBtn.addEventListener('click', function() {
        zoomLevel = Math.min(maxZoom, zoomLevel + 0.5);
        aplicarZoom();
      });
      
      // Zoom com clique na imagem
      imagem.addEventListener('click', function(e) {
        if (zoomLevel === 1) {
          zoomLevel = 2;
        } else {
          zoomLevel = 1;
        }
        aplicarZoom();
      });
      
      // Zoom com duplo clique
      imagem.addEventListener('dblclick', function(e) {
        e.preventDefault();
        
        if (zoomLevel < maxZoom) {
          zoomLevel = maxZoom;
        } else {
          zoomLevel = 1;
        }
        
        // Aplicar zoom no ponto clicado
        if (zoomLevel > 1) {
          const rect = imagem.getBoundingClientRect();
          const x = (e.clientX - rect.left) / rect.width * 100;
          const y = (e.clientY - rect.top) / rect.height * 100;
          imagem.style.transformOrigin = `${x}% ${y}%`;
        }
        
        aplicarZoom();
      });
      
      // Zoom com roda do mouse
      imagem.addEventListener('wheel', function(e) {
        e.preventDefault();
        
        if (e.deltaY < 0) {
          zoomLevel = Math.min(maxZoom, zoomLevel + 0.25);
        } else {
          zoomLevel = Math.max(minZoom, zoomLevel - 0.25);
        }
        
        // Aplicar zoom no ponto do mouse
        if (zoomLevel > 1) {
          const rect = imagem.getBoundingClientRect();
          const x = (e.clientX - rect.left) / rect.width * 100;
          const y = (e.clientY - rect.top) / rect.height * 100;
          imagem.style.transformOrigin = `${x}% ${y}%`;
        }
        
        aplicarZoom();
      }, { passive: false });
      
      // Movimento da imagem quando ampliada
      let arrastando = false;
      let inicioX, inicioY, origemInicialX, origemInicialY;
      
      imagem.addEventListener('mousedown', function(e) {
        if (zoomLevel > 1) {
          arrastando = true;
          inicioX = e.clientX;
          inicioY = e.clientY;
          
          const origem = imagem.style.transformOrigin;
          const [x, y] = origem ? origem.split(' ').map(val => parseFloat(val)) : [50, 50];
          origemInicialX = x || 50;
          origemInicialY = y || 50;
          
          e.preventDefault();
        }
      });
      
      document.addEventListener('mousemove', function(e) {
        if (arrastando && zoomLevel > 1) {
          const deltaX = e.clientX - inicioX;
          const deltaY = e.clientY - inicioY;
          
          const sensibilidade = 100 / zoomLevel;
          const novoX = Math.max(0, Math.min(100, origemInicialX - (deltaX / sensibilidade)));
          const novoY = Math.max(0, Math.min(100, origemInicialY - (deltaY / sensibilidade)));
          
          imagem.style.transformOrigin = `${novoX}% ${novoY}%`;
        }
      });
      
      document.addEventListener('mouseup', function() {
        arrastando = false;
      });
      
      imagem.addEventListener('mouseleave', function() {
        arrastando = false;
      });
      
      // Suporte a toque para dispositivos móveis
      imagem.addEventListener('touchstart', function(e) {
        if (zoomLevel > 1 && e.touches.length === 1) {
          arrastando = true;
          inicioX = e.touches[0].clientX;
          inicioY = e.touches[0].clientY;
          
          const origem = imagem.style.transformOrigin;
          const [x, y] = origem ? origem.split(' ').map(val => parseFloat(val)) : [50, 50];
          origemInicialX = x || 50;
          origemInicialY = y || 50;
          
          e.preventDefault();
        }
      }, { passive: false });
      
      imagem.addEventListener('touchmove', function(e) {
        if (arrastando && zoomLevel > 1 && e.touches.length === 1) {
          const deltaX = e.touches[0].clientX - inicioX;
          const deltaY = e.touches[0].clientY - inicioY;
          
          const sensibilidade = 100 / zoomLevel;
          const novoX = Math.max(0, Math.min(100, origemInicialX - (deltaX / sensibilidade)));
          const novoY = Math.max(0, Math.min(100, origemInicialY - (deltaY / sensibilidade)));
          
          imagem.style.transformOrigin = `${novoX}% ${novoY}%`;
          e.preventDefault();
        }
      }, { passive: false });
      
      imagem.addEventListener('touchend', function() {
        arrastando = false;
      });
      
      // Mostrar o modal
      setTimeout(() => {
        modal.style.opacity = '1';
      }, 10);
      
      return true;
    } catch (error) {
      console.error("Erro ao criar modal:", error);
      return false;
    }
  }
  
  // 4. Adicionar estilos CSS diretamente
  function adicionarEstilos() {
    const estilos = document.createElement('style');
    estilos.id = 'novoModalEstilos';
    estilos.textContent = `
      /* Estilos para o novo modal */
      .novo-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.9);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 9999;
        opacity: 0;
        transition: opacity 0.3s ease;
      }
      
      .novo-modal-content {
        width: 95%;
        height: 95vh;
        background-color: var(--bg-secondary, #ffffff);
        border-radius: 12px;
        overflow: hidden;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        display: flex;
        flex-direction: column;
        position: relative;
      }
      
      .novo-modal-close {
        position: absolute;
        top: 15px;
        right: 20px;
        font-size: 2rem;
        color: var(--primary-color, #3498db);
        cursor: pointer;
        z-index: 100;
        width: 40px;
        height: 40px;
        background-color: rgba(255, 255, 255, 0.8);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      }
      
      .novo-modal-body {
        flex: 1;
        display: flex;
        flex-direction: column;
        position: relative;
        overflow: hidden;
        padding-top: 0;
      }
      
      .novo-modal-image-container {
        flex: 1;
        display: flex;
        justify-content: center;
        align-items: center;
        position: relative;
        padding: 20px;
      }
      
      .novo-modal-image {
        max-width: 90%;
        max-height: 75vh;
        object-fit: contain;
        transition: transform 0.3s ease;
        cursor: pointer;
      }
      
      .novo-modal-info {
        width: 100%;
        text-align: center;
        padding: 15px 25px;
        background-color: var(--bg-primary, #f8f9fa);
        border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        margin-top: 0;
        position: relative;
        z-index: 5;
      }
      
      .produto-nome {
        font-size: 1.8rem;
        font-weight: bold;
        margin: 0 0 10px 0;
        color: var(--text-color, #333333);
      }
      
      .produto-sku {
        font-size: 1.2rem;
        color: var(--primary-color, #3498db);
        margin: 0;
        font-weight: 500;
      }
      
      .zoom-controls {
        position: absolute;
        right: 20px;
        top: 50%;
        transform: translateY(-50%);
        display: flex;
        flex-direction: column;
        gap: 15px;
        z-index: 10;
      }
      
      .zoom-btn {
        width: 45px;
        height: 45px;
        border-radius: 50%;
        background-color: rgba(52, 152, 219, 0.5);
        color: white;
        border: none;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 18px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.15);
        opacity: 0.7;
        transition: opacity 0.3s, transform 0.2s;
      }
      
      .zoom-btn.zoom-reset {
        background-color: rgba(230, 126, 34, 0.5);
      }
      
      .zoom-btn:hover {
        transform: scale(1.1);
        opacity: 1;
      }
      
      /* Responsividade */
      @media (max-width: 768px) {
        .novo-modal-content {
          width: 98%;
          height: 98vh;
        }
        
        .produto-nome {
          font-size: 1.4rem;
        }
        
        .zoom-btn {
          width: 40px;
          height: 40px;
          font-size: 16px;
        }
      }
    `;
    
    document.head.appendChild(estilos);
  }
  
  // 5. Adicionar eventos de clique a todos os produtos
  function adicionarEventosClique() {
    // Procurar por elementos com a classe 'product-img-container' ou 'product img'
    const produtoImagens = document.querySelectorAll('.product-img-container img, .product img');
    
    produtoImagens.forEach(img => {
      // Adicionar evento de clique que chama a função openImageModal
      img.addEventListener('click', function(e) {
        // Evitar comportamento padrão
        e.preventDefault();
        e.stopPropagation();
        
        // Obter o elemento pai do produto
        const produtoElemento = img.closest('.product');
        if (!produtoElemento) return;
        
        // Obter informações do produto
        const sku = produtoElemento.getAttribute('data-sku') || '';
        
        // Tentar encontrar o nome do produto
        let nome = '';
        const nomeElemento = produtoElemento.querySelector('.product-name');
        if (nomeElemento) {
          nome = nomeElemento.textContent || '';
        }
        
        // Se não encontrar o nome, tentar obter de outros elementos
        if (!nome) {
          // Tentar obter de elementos comuns que podem conter o nome
          const possiveisElementosNome = [
            produtoElemento.querySelector('h3'),
            produtoElemento.querySelector('.marca'),
            produtoElemento.querySelector('[class*="name"]'),
            produtoElemento.querySelector('[class*="titulo"]'),
            produtoElemento.querySelector('[class*="title"]')
          ];
          
          for (let elemento of possiveisElementosNome) {
            if (elemento && elemento.textContent) {
              nome = elemento.textContent.trim();
              console.log("Nome encontrado em elemento alternativo:", nome);
              break;
            }
          }
        }
        
        // Obter a URL da imagem
        const imgSrc = img.src || '';
        
        // Chamar a função openImageModal (nossa função substituída)
        if (typeof window.openImageModal === 'function') {
          window.openImageModal(imgSrc, sku, nome);
        } else {
          console.error("Função openImageModal não está disponível");
          // Tentar criar nosso modal diretamente
          criarEMostrarNovoModal(imgSrc, sku, nome);
        }
      });
    });
  }
  
  // Executar inicialização com base no status de carregamento da página
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', inicializar);
  } else {
    // Documento já está pronto
    inicializar();
  }
  
  // Além disso, criar um observador para capturar novos produtos adicionados ao DOM
  const observador = new MutationObserver(function(mutacoes) {
    mutacoes.forEach(function(mutacao) {
      if (mutacao.type === 'childList' && mutacao.addedNodes.length) {
        // Verificar se foram adicionados produtos
        const novoProdutoAdicionado = Array.from(mutacao.addedNodes).some(
          node => node.classList && (node.classList.contains('product') || node.querySelectorAll('.product').length > 0)
        );
        
        if (novoProdutoAdicionado) {
          // Adicionar eventos de clique aos novos produtos
          adicionarEventosClique();
        }
      }
    });
  });
  
  // Iniciar observação
  observador.observe(document.body, { childList: true, subtree: true });
})();


	</script>
 <script>
    (function() {
        // --- Configurações ---
        // Larguras mínimas base correspondentes às media queries CSS (em pixels)
        const baseMinWidths = {
            small: 105,  // <= 576px
            medium: 140, // <= 768px
            large: 160,  // <= 1024px
            xlarge: 180  // > 1024px
        };
        // Limites para a largura mínima calculada (evita valores extremos)
        const minPossibleWidth = 60;  // Largura mínima absoluta permitida (pixels)
        const maxPossibleWidth = 350; // Largura máxima absoluta permitida (pixels)
        // Delay para throttling (evita execuções excessivas durante zoom rápido)
        const throttleDelay = 100; // ms

        // --- Variáveis ---
        let throttleTimeout = null;
        const rootStyle = document.documentElement.style;

        // --- Funções ---

        // Função para obter a largura base correta para a largura atual da janela
        function getBaseMinWidth() {
            const windowWidth = window.innerWidth;
            if (windowWidth <= 576) return baseMinWidths.small;
            if (windowWidth <= 768) return baseMinWidths.medium;
            if (windowWidth <= 1024) return baseMinWidths.large;
            return baseMinWidths.xlarge;
        }

       // Função principal que calcula e atualiza a variável CSS (AJUSTADA)
       function updateMinWidthBasedOnZoom() {
            const baseWidth = getBaseMinWidth(); // Pega a largura base para o tamanho da tela atual

            // Valor padrão é a largura base (para zoom nativo do PC)
            let finalMinWidth = baseWidth;

            // Tenta usar visualViewport APENAS se ele existir E a escala for diferente de 1 (indicando pinch-zoom)
            if (window.visualViewport) {
                 const scale = window.visualViewport.scale;
                 // Só ajusta se o zoom for significativamente diferente de 1
                 if (Math.abs(scale - 1) > 0.05) {
                      console.log(`Ajustando para escala visual: ${scale.toFixed(2)}`);
                      finalMinWidth = baseWidth / scale;
                 } else {
                     console.log("Usando largura base (escala próxima a 1)");
                 }
            } else {
                 console.warn("window.visualViewport não suportado.");
            }

            // Aplicar limites para evitar valores extremos
            finalMinWidth = Math.max(minPossibleWidth, Math.min(maxPossibleWidth, finalMinWidth));

            // Atualizar a variável CSS
            window.requestAnimationFrame(() => {
                 rootStyle.setProperty('--coluna-produto-min-width', `${finalMinWidth.toFixed(2)}px`);
                 // console.log(`Largura Mínima Final: ${finalMinWidth.toFixed(2)}px`);
            });
        }

        // Função throttled para o evento resize/zoom
        function throttledUpdate() {
            if (!throttleTimeout) {
                throttleTimeout = setTimeout(() => {
                    updateMinWidthBasedOnZoom();
                    throttleTimeout = null; // Limpa o timeout para a próxima execução
                }, throttleDelay);
            }
        }

        // --- Inicialização ---

        // Chamar a função uma vez no carregamento inicial
        updateMinWidthBasedOnZoom();

        // Adicionar listener para o evento 'resize' do visualViewport
        if (window.visualViewport) {
            window.visualViewport.addEventListener('resize', throttledUpdate);
        } else {
            // Fallback para navegadores mais antigos (menos preciso para zoom)
            window.addEventListener('resize', throttledUpdate);
            // Tentar detectar zoom de outras formas (menos confiável)
             let lastWidth = window.innerWidth;
             setInterval(() => {
                 if(window.innerWidth !== lastWidth) {
                     lastWidth = window.innerWidth;
                     throttledUpdate();
                 }
             }, 500); // Verifica a cada 500ms
        }

        console.log("Controle dinâmico de colunas por zoom inicializado.");

    })();
    </script>
    
</body>
</html>
